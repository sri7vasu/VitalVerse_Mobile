"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
async function serializeAws_restJson1_1CreateAppCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps";
    let body;
    if (input.CreateApplicationRequest !== undefined) {
        body = serializeAws_restJson1_1CreateApplicationRequest(input.CreateApplicationRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateAppCommand = serializeAws_restJson1_1CreateAppCommand;
async function serializeAws_restJson1_1CreateCampaignCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.WriteCampaignRequest !== undefined) {
        body = serializeAws_restJson1_1WriteCampaignRequest(input.WriteCampaignRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateCampaignCommand = serializeAws_restJson1_1CreateCampaignCommand;
async function serializeAws_restJson1_1CreateEmailTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/email";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    let body;
    if (input.EmailTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1EmailTemplateRequest(input.EmailTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateEmailTemplateCommand = serializeAws_restJson1_1CreateEmailTemplateCommand;
async function serializeAws_restJson1_1CreateExportJobCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/jobs/export";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.ExportJobRequest !== undefined) {
        body = serializeAws_restJson1_1ExportJobRequest(input.ExportJobRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateExportJobCommand = serializeAws_restJson1_1CreateExportJobCommand;
async function serializeAws_restJson1_1CreateImportJobCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/jobs/import";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.ImportJobRequest !== undefined) {
        body = serializeAws_restJson1_1ImportJobRequest(input.ImportJobRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateImportJobCommand = serializeAws_restJson1_1CreateImportJobCommand;
async function serializeAws_restJson1_1CreateJourneyCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.WriteJourneyRequest !== undefined) {
        body = serializeAws_restJson1_1WriteJourneyRequest(input.WriteJourneyRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateJourneyCommand = serializeAws_restJson1_1CreateJourneyCommand;
async function serializeAws_restJson1_1CreatePushTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/push";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    let body;
    if (input.PushNotificationTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1PushNotificationTemplateRequest(input.PushNotificationTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreatePushTemplateCommand = serializeAws_restJson1_1CreatePushTemplateCommand;
async function serializeAws_restJson1_1CreateSegmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.WriteSegmentRequest !== undefined) {
        body = serializeAws_restJson1_1WriteSegmentRequest(input.WriteSegmentRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateSegmentCommand = serializeAws_restJson1_1CreateSegmentCommand;
async function serializeAws_restJson1_1CreateSmsTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/sms";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    let body;
    if (input.SMSTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1SMSTemplateRequest(input.SMSTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateSmsTemplateCommand = serializeAws_restJson1_1CreateSmsTemplateCommand;
async function serializeAws_restJson1_1CreateVoiceTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/voice";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    let body;
    if (input.VoiceTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1VoiceTemplateRequest(input.VoiceTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1CreateVoiceTemplateCommand = serializeAws_restJson1_1CreateVoiceTemplateCommand;
async function serializeAws_restJson1_1DeleteAdmChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/adm";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteAdmChannelCommand = serializeAws_restJson1_1DeleteAdmChannelCommand;
async function serializeAws_restJson1_1DeleteApnsChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteApnsChannelCommand = serializeAws_restJson1_1DeleteApnsChannelCommand;
async function serializeAws_restJson1_1DeleteApnsSandboxChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_sandbox";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteApnsSandboxChannelCommand = serializeAws_restJson1_1DeleteApnsSandboxChannelCommand;
async function serializeAws_restJson1_1DeleteApnsVoipChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteApnsVoipChannelCommand = serializeAws_restJson1_1DeleteApnsVoipChannelCommand;
async function serializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip_sandbox";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand = serializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand;
async function serializeAws_restJson1_1DeleteAppCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteAppCommand = serializeAws_restJson1_1DeleteAppCommand;
async function serializeAws_restJson1_1DeleteBaiduChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/baidu";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteBaiduChannelCommand = serializeAws_restJson1_1DeleteBaiduChannelCommand;
async function serializeAws_restJson1_1DeleteCampaignCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteCampaignCommand = serializeAws_restJson1_1DeleteCampaignCommand;
async function serializeAws_restJson1_1DeleteEmailChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/email";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteEmailChannelCommand = serializeAws_restJson1_1DeleteEmailChannelCommand;
async function serializeAws_restJson1_1DeleteEmailTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/email";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1DeleteEmailTemplateCommand = serializeAws_restJson1_1DeleteEmailTemplateCommand;
async function serializeAws_restJson1_1DeleteEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/endpoints/{EndpointId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.EndpointId !== undefined) {
        const labelValue = input.EndpointId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: EndpointId.");
        }
        resolvedPath = resolvedPath.replace("{EndpointId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: EndpointId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteEndpointCommand = serializeAws_restJson1_1DeleteEndpointCommand;
async function serializeAws_restJson1_1DeleteEventStreamCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/eventstream";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteEventStreamCommand = serializeAws_restJson1_1DeleteEventStreamCommand;
async function serializeAws_restJson1_1DeleteGcmChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/gcm";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteGcmChannelCommand = serializeAws_restJson1_1DeleteGcmChannelCommand;
async function serializeAws_restJson1_1DeleteJourneyCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteJourneyCommand = serializeAws_restJson1_1DeleteJourneyCommand;
async function serializeAws_restJson1_1DeletePushTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/push";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1DeletePushTemplateCommand = serializeAws_restJson1_1DeletePushTemplateCommand;
async function serializeAws_restJson1_1DeleteSegmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteSegmentCommand = serializeAws_restJson1_1DeleteSegmentCommand;
async function serializeAws_restJson1_1DeleteSmsChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/sms";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteSmsChannelCommand = serializeAws_restJson1_1DeleteSmsChannelCommand;
async function serializeAws_restJson1_1DeleteSmsTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/sms";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1DeleteSmsTemplateCommand = serializeAws_restJson1_1DeleteSmsTemplateCommand;
async function serializeAws_restJson1_1DeleteUserEndpointsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/users/{UserId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.UserId !== undefined) {
        const labelValue = input.UserId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: UserId.");
        }
        resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: UserId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteUserEndpointsCommand = serializeAws_restJson1_1DeleteUserEndpointsCommand;
async function serializeAws_restJson1_1DeleteVoiceChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/voice";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteVoiceChannelCommand = serializeAws_restJson1_1DeleteVoiceChannelCommand;
async function serializeAws_restJson1_1DeleteVoiceTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/voice";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1DeleteVoiceTemplateCommand = serializeAws_restJson1_1DeleteVoiceTemplateCommand;
async function serializeAws_restJson1_1GetAdmChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/adm";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetAdmChannelCommand = serializeAws_restJson1_1GetAdmChannelCommand;
async function serializeAws_restJson1_1GetApnsChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetApnsChannelCommand = serializeAws_restJson1_1GetApnsChannelCommand;
async function serializeAws_restJson1_1GetApnsSandboxChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_sandbox";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetApnsSandboxChannelCommand = serializeAws_restJson1_1GetApnsSandboxChannelCommand;
async function serializeAws_restJson1_1GetApnsVoipChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetApnsVoipChannelCommand = serializeAws_restJson1_1GetApnsVoipChannelCommand;
async function serializeAws_restJson1_1GetApnsVoipSandboxChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip_sandbox";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetApnsVoipSandboxChannelCommand = serializeAws_restJson1_1GetApnsVoipSandboxChannelCommand;
async function serializeAws_restJson1_1GetAppCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetAppCommand = serializeAws_restJson1_1GetAppCommand;
async function serializeAws_restJson1_1GetApplicationDateRangeKpiCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/kpis/daterange/{KpiName}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.KpiName !== undefined) {
        const labelValue = input.KpiName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: KpiName.");
        }
        resolvedPath = resolvedPath.replace("{KpiName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: KpiName.");
    }
    const query = {};
    if (input.EndTime !== undefined) {
        query["end-time"] = (input.EndTime.toISOString().split(".")[0] + "Z").toString();
    }
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.StartTime !== undefined) {
        query["start-time"] = (input.StartTime.toISOString().split(".")[0] + "Z").toString();
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetApplicationDateRangeKpiCommand = serializeAws_restJson1_1GetApplicationDateRangeKpiCommand;
async function serializeAws_restJson1_1GetApplicationSettingsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/settings";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetApplicationSettingsCommand = serializeAws_restJson1_1GetApplicationSettingsCommand;
async function serializeAws_restJson1_1GetAppsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps";
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetAppsCommand = serializeAws_restJson1_1GetAppsCommand;
async function serializeAws_restJson1_1GetBaiduChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/baidu";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetBaiduChannelCommand = serializeAws_restJson1_1GetBaiduChannelCommand;
async function serializeAws_restJson1_1GetCampaignCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetCampaignCommand = serializeAws_restJson1_1GetCampaignCommand;
async function serializeAws_restJson1_1GetCampaignActivitiesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/activities";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetCampaignActivitiesCommand = serializeAws_restJson1_1GetCampaignActivitiesCommand;
async function serializeAws_restJson1_1GetCampaignDateRangeKpiCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/kpis/daterange/{KpiName}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    if (input.KpiName !== undefined) {
        const labelValue = input.KpiName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: KpiName.");
        }
        resolvedPath = resolvedPath.replace("{KpiName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: KpiName.");
    }
    const query = {};
    if (input.EndTime !== undefined) {
        query["end-time"] = (input.EndTime.toISOString().split(".")[0] + "Z").toString();
    }
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.StartTime !== undefined) {
        query["start-time"] = (input.StartTime.toISOString().split(".")[0] + "Z").toString();
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetCampaignDateRangeKpiCommand = serializeAws_restJson1_1GetCampaignDateRangeKpiCommand;
async function serializeAws_restJson1_1GetCampaignVersionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/versions/{Version}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    if (input.Version !== undefined) {
        const labelValue = input.Version;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: Version.");
        }
        resolvedPath = resolvedPath.replace("{Version}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: Version.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetCampaignVersionCommand = serializeAws_restJson1_1GetCampaignVersionCommand;
async function serializeAws_restJson1_1GetCampaignVersionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/versions";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetCampaignVersionsCommand = serializeAws_restJson1_1GetCampaignVersionsCommand;
async function serializeAws_restJson1_1GetCampaignsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetCampaignsCommand = serializeAws_restJson1_1GetCampaignsCommand;
async function serializeAws_restJson1_1GetChannelsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetChannelsCommand = serializeAws_restJson1_1GetChannelsCommand;
async function serializeAws_restJson1_1GetEmailChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/email";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetEmailChannelCommand = serializeAws_restJson1_1GetEmailChannelCommand;
async function serializeAws_restJson1_1GetEmailTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/email";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetEmailTemplateCommand = serializeAws_restJson1_1GetEmailTemplateCommand;
async function serializeAws_restJson1_1GetEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/endpoints/{EndpointId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.EndpointId !== undefined) {
        const labelValue = input.EndpointId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: EndpointId.");
        }
        resolvedPath = resolvedPath.replace("{EndpointId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: EndpointId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetEndpointCommand = serializeAws_restJson1_1GetEndpointCommand;
async function serializeAws_restJson1_1GetEventStreamCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/eventstream";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetEventStreamCommand = serializeAws_restJson1_1GetEventStreamCommand;
async function serializeAws_restJson1_1GetExportJobCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/jobs/export/{JobId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JobId !== undefined) {
        const labelValue = input.JobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JobId.");
        }
        resolvedPath = resolvedPath.replace("{JobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JobId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetExportJobCommand = serializeAws_restJson1_1GetExportJobCommand;
async function serializeAws_restJson1_1GetExportJobsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/jobs/export";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetExportJobsCommand = serializeAws_restJson1_1GetExportJobsCommand;
async function serializeAws_restJson1_1GetGcmChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/gcm";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetGcmChannelCommand = serializeAws_restJson1_1GetGcmChannelCommand;
async function serializeAws_restJson1_1GetImportJobCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/jobs/import/{JobId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JobId !== undefined) {
        const labelValue = input.JobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JobId.");
        }
        resolvedPath = resolvedPath.replace("{JobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JobId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetImportJobCommand = serializeAws_restJson1_1GetImportJobCommand;
async function serializeAws_restJson1_1GetImportJobsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/jobs/import";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetImportJobsCommand = serializeAws_restJson1_1GetImportJobsCommand;
async function serializeAws_restJson1_1GetJourneyCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetJourneyCommand = serializeAws_restJson1_1GetJourneyCommand;
async function serializeAws_restJson1_1GetJourneyDateRangeKpiCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}/kpis/daterange/{KpiName}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    if (input.KpiName !== undefined) {
        const labelValue = input.KpiName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: KpiName.");
        }
        resolvedPath = resolvedPath.replace("{KpiName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: KpiName.");
    }
    const query = {};
    if (input.EndTime !== undefined) {
        query["end-time"] = (input.EndTime.toISOString().split(".")[0] + "Z").toString();
    }
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.StartTime !== undefined) {
        query["start-time"] = (input.StartTime.toISOString().split(".")[0] + "Z").toString();
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetJourneyDateRangeKpiCommand = serializeAws_restJson1_1GetJourneyDateRangeKpiCommand;
async function serializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}/activities/{JourneyActivityId}/execution-metrics";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyActivityId !== undefined) {
        const labelValue = input.JourneyActivityId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyActivityId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyActivityId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyActivityId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    const query = {};
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand = serializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand;
async function serializeAws_restJson1_1GetJourneyExecutionMetricsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}/execution-metrics";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    const query = {};
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetJourneyExecutionMetricsCommand = serializeAws_restJson1_1GetJourneyExecutionMetricsCommand;
async function serializeAws_restJson1_1GetPushTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/push";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetPushTemplateCommand = serializeAws_restJson1_1GetPushTemplateCommand;
async function serializeAws_restJson1_1GetSegmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetSegmentCommand = serializeAws_restJson1_1GetSegmentCommand;
async function serializeAws_restJson1_1GetSegmentExportJobsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}/jobs/export";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetSegmentExportJobsCommand = serializeAws_restJson1_1GetSegmentExportJobsCommand;
async function serializeAws_restJson1_1GetSegmentImportJobsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}/jobs/import";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetSegmentImportJobsCommand = serializeAws_restJson1_1GetSegmentImportJobsCommand;
async function serializeAws_restJson1_1GetSegmentVersionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}/versions/{Version}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    if (input.Version !== undefined) {
        const labelValue = input.Version;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: Version.");
        }
        resolvedPath = resolvedPath.replace("{Version}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: Version.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetSegmentVersionCommand = serializeAws_restJson1_1GetSegmentVersionCommand;
async function serializeAws_restJson1_1GetSegmentVersionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}/versions";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetSegmentVersionsCommand = serializeAws_restJson1_1GetSegmentVersionsCommand;
async function serializeAws_restJson1_1GetSegmentsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetSegmentsCommand = serializeAws_restJson1_1GetSegmentsCommand;
async function serializeAws_restJson1_1GetSmsChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/sms";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetSmsChannelCommand = serializeAws_restJson1_1GetSmsChannelCommand;
async function serializeAws_restJson1_1GetSmsTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/sms";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetSmsTemplateCommand = serializeAws_restJson1_1GetSmsTemplateCommand;
async function serializeAws_restJson1_1GetUserEndpointsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/users/{UserId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.UserId !== undefined) {
        const labelValue = input.UserId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: UserId.");
        }
        resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: UserId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetUserEndpointsCommand = serializeAws_restJson1_1GetUserEndpointsCommand;
async function serializeAws_restJson1_1GetVoiceChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/voice";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetVoiceChannelCommand = serializeAws_restJson1_1GetVoiceChannelCommand;
async function serializeAws_restJson1_1GetVoiceTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/voice";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1GetVoiceTemplateCommand = serializeAws_restJson1_1GetVoiceTemplateCommand;
async function serializeAws_restJson1_1ListJourneysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    const query = {};
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Token !== undefined) {
        query["token"] = input.Token;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1ListJourneysCommand = serializeAws_restJson1_1ListJourneysCommand;
async function serializeAws_restJson1_1ListTagsForResourceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/tags/{ResourceArn}";
    if (input.ResourceArn !== undefined) {
        const labelValue = input.ResourceArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ResourceArn.");
        }
        resolvedPath = resolvedPath.replace("{ResourceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ResourceArn.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1ListTagsForResourceCommand = serializeAws_restJson1_1ListTagsForResourceCommand;
async function serializeAws_restJson1_1ListTemplateVersionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates/{TemplateName}/{TemplateType}/versions";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    if (input.TemplateType !== undefined) {
        const labelValue = input.TemplateType;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateType.");
        }
        resolvedPath = resolvedPath.replace("{TemplateType}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateType.");
    }
    const query = {};
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1ListTemplateVersionsCommand = serializeAws_restJson1_1ListTemplateVersionsCommand;
async function serializeAws_restJson1_1ListTemplatesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/templates";
    const query = {};
    if (input.NextToken !== undefined) {
        query["next-token"] = input.NextToken;
    }
    if (input.PageSize !== undefined) {
        query["page-size"] = input.PageSize;
    }
    if (input.Prefix !== undefined) {
        query["prefix"] = input.Prefix;
    }
    if (input.TemplateType !== undefined) {
        query["template-type"] = input.TemplateType;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1ListTemplatesCommand = serializeAws_restJson1_1ListTemplatesCommand;
async function serializeAws_restJson1_1PhoneNumberValidateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/phone/number/validate";
    let body;
    if (input.NumberValidateRequest !== undefined) {
        body = serializeAws_restJson1_1NumberValidateRequest(input.NumberValidateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1PhoneNumberValidateCommand = serializeAws_restJson1_1PhoneNumberValidateCommand;
async function serializeAws_restJson1_1PutEventStreamCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/eventstream";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.WriteEventStream !== undefined) {
        body = serializeAws_restJson1_1WriteEventStream(input.WriteEventStream, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1PutEventStreamCommand = serializeAws_restJson1_1PutEventStreamCommand;
async function serializeAws_restJson1_1PutEventsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/events";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.EventsRequest !== undefined) {
        body = serializeAws_restJson1_1EventsRequest(input.EventsRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1PutEventsCommand = serializeAws_restJson1_1PutEventsCommand;
async function serializeAws_restJson1_1RemoveAttributesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/attributes/{AttributeType}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.AttributeType !== undefined) {
        const labelValue = input.AttributeType;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: AttributeType.");
        }
        resolvedPath = resolvedPath.replace("{AttributeType}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: AttributeType.");
    }
    let body;
    if (input.UpdateAttributesRequest !== undefined) {
        body = serializeAws_restJson1_1UpdateAttributesRequest(input.UpdateAttributesRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1RemoveAttributesCommand = serializeAws_restJson1_1RemoveAttributesCommand;
async function serializeAws_restJson1_1SendMessagesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/messages";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.MessageRequest !== undefined) {
        body = serializeAws_restJson1_1MessageRequest(input.MessageRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1SendMessagesCommand = serializeAws_restJson1_1SendMessagesCommand;
async function serializeAws_restJson1_1SendUsersMessagesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/users-messages";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.SendUsersMessageRequest !== undefined) {
        body = serializeAws_restJson1_1SendUsersMessageRequest(input.SendUsersMessageRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1SendUsersMessagesCommand = serializeAws_restJson1_1SendUsersMessagesCommand;
async function serializeAws_restJson1_1TagResourceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/tags/{ResourceArn}";
    if (input.ResourceArn !== undefined) {
        const labelValue = input.ResourceArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ResourceArn.");
        }
        resolvedPath = resolvedPath.replace("{ResourceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ResourceArn.");
    }
    let body;
    if (input.TagsModel !== undefined) {
        body = serializeAws_restJson1_1TagsModel(input.TagsModel, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1TagResourceCommand = serializeAws_restJson1_1TagResourceCommand;
async function serializeAws_restJson1_1UntagResourceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/tags/{ResourceArn}";
    if (input.ResourceArn !== undefined) {
        const labelValue = input.ResourceArn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ResourceArn.");
        }
        resolvedPath = resolvedPath.replace("{ResourceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ResourceArn.");
    }
    const query = {};
    if (input.TagKeys !== undefined) {
        query["tagKeys"] = (input.TagKeys || []).map(_entry => _entry);
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1UntagResourceCommand = serializeAws_restJson1_1UntagResourceCommand;
async function serializeAws_restJson1_1UpdateAdmChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/adm";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.ADMChannelRequest !== undefined) {
        body = serializeAws_restJson1_1ADMChannelRequest(input.ADMChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateAdmChannelCommand = serializeAws_restJson1_1UpdateAdmChannelCommand;
async function serializeAws_restJson1_1UpdateApnsChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.APNSChannelRequest !== undefined) {
        body = serializeAws_restJson1_1APNSChannelRequest(input.APNSChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateApnsChannelCommand = serializeAws_restJson1_1UpdateApnsChannelCommand;
async function serializeAws_restJson1_1UpdateApnsSandboxChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_sandbox";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.APNSSandboxChannelRequest !== undefined) {
        body = serializeAws_restJson1_1APNSSandboxChannelRequest(input.APNSSandboxChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateApnsSandboxChannelCommand = serializeAws_restJson1_1UpdateApnsSandboxChannelCommand;
async function serializeAws_restJson1_1UpdateApnsVoipChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.APNSVoipChannelRequest !== undefined) {
        body = serializeAws_restJson1_1APNSVoipChannelRequest(input.APNSVoipChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateApnsVoipChannelCommand = serializeAws_restJson1_1UpdateApnsVoipChannelCommand;
async function serializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip_sandbox";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.APNSVoipSandboxChannelRequest !== undefined) {
        body = serializeAws_restJson1_1APNSVoipSandboxChannelRequest(input.APNSVoipSandboxChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand = serializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand;
async function serializeAws_restJson1_1UpdateApplicationSettingsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/settings";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.WriteApplicationSettingsRequest !== undefined) {
        body = serializeAws_restJson1_1WriteApplicationSettingsRequest(input.WriteApplicationSettingsRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateApplicationSettingsCommand = serializeAws_restJson1_1UpdateApplicationSettingsCommand;
async function serializeAws_restJson1_1UpdateBaiduChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/baidu";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.BaiduChannelRequest !== undefined) {
        body = serializeAws_restJson1_1BaiduChannelRequest(input.BaiduChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateBaiduChannelCommand = serializeAws_restJson1_1UpdateBaiduChannelCommand;
async function serializeAws_restJson1_1UpdateCampaignCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.CampaignId !== undefined) {
        const labelValue = input.CampaignId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: CampaignId.");
        }
        resolvedPath = resolvedPath.replace("{CampaignId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: CampaignId.");
    }
    let body;
    if (input.WriteCampaignRequest !== undefined) {
        body = serializeAws_restJson1_1WriteCampaignRequest(input.WriteCampaignRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateCampaignCommand = serializeAws_restJson1_1UpdateCampaignCommand;
async function serializeAws_restJson1_1UpdateEmailChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/email";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.EmailChannelRequest !== undefined) {
        body = serializeAws_restJson1_1EmailChannelRequest(input.EmailChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateEmailChannelCommand = serializeAws_restJson1_1UpdateEmailChannelCommand;
async function serializeAws_restJson1_1UpdateEmailTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/email";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.CreateNewVersion !== undefined) {
        query["create-new-version"] = input.CreateNewVersion.toString();
    }
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    if (input.EmailTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1EmailTemplateRequest(input.EmailTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1UpdateEmailTemplateCommand = serializeAws_restJson1_1UpdateEmailTemplateCommand;
async function serializeAws_restJson1_1UpdateEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/endpoints/{EndpointId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.EndpointId !== undefined) {
        const labelValue = input.EndpointId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: EndpointId.");
        }
        resolvedPath = resolvedPath.replace("{EndpointId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: EndpointId.");
    }
    let body;
    if (input.EndpointRequest !== undefined) {
        body = serializeAws_restJson1_1EndpointRequest(input.EndpointRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateEndpointCommand = serializeAws_restJson1_1UpdateEndpointCommand;
async function serializeAws_restJson1_1UpdateEndpointsBatchCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/endpoints";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.EndpointBatchRequest !== undefined) {
        body = serializeAws_restJson1_1EndpointBatchRequest(input.EndpointBatchRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateEndpointsBatchCommand = serializeAws_restJson1_1UpdateEndpointsBatchCommand;
async function serializeAws_restJson1_1UpdateGcmChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/gcm";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.GCMChannelRequest !== undefined) {
        body = serializeAws_restJson1_1GCMChannelRequest(input.GCMChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateGcmChannelCommand = serializeAws_restJson1_1UpdateGcmChannelCommand;
async function serializeAws_restJson1_1UpdateJourneyCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    let body;
    if (input.WriteJourneyRequest !== undefined) {
        body = serializeAws_restJson1_1WriteJourneyRequest(input.WriteJourneyRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateJourneyCommand = serializeAws_restJson1_1UpdateJourneyCommand;
async function serializeAws_restJson1_1UpdateJourneyStateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}/state";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.JourneyId !== undefined) {
        const labelValue = input.JourneyId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: JourneyId.");
        }
        resolvedPath = resolvedPath.replace("{JourneyId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: JourneyId.");
    }
    let body;
    if (input.JourneyStateRequest !== undefined) {
        body = serializeAws_restJson1_1JourneyStateRequest(input.JourneyStateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateJourneyStateCommand = serializeAws_restJson1_1UpdateJourneyStateCommand;
async function serializeAws_restJson1_1UpdatePushTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/push";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.CreateNewVersion !== undefined) {
        query["create-new-version"] = input.CreateNewVersion.toString();
    }
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    if (input.PushNotificationTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1PushNotificationTemplateRequest(input.PushNotificationTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1UpdatePushTemplateCommand = serializeAws_restJson1_1UpdatePushTemplateCommand;
async function serializeAws_restJson1_1UpdateSegmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    if (input.SegmentId !== undefined) {
        const labelValue = input.SegmentId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: SegmentId.");
        }
        resolvedPath = resolvedPath.replace("{SegmentId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: SegmentId.");
    }
    let body;
    if (input.WriteSegmentRequest !== undefined) {
        body = serializeAws_restJson1_1WriteSegmentRequest(input.WriteSegmentRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateSegmentCommand = serializeAws_restJson1_1UpdateSegmentCommand;
async function serializeAws_restJson1_1UpdateSmsChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/sms";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.SMSChannelRequest !== undefined) {
        body = serializeAws_restJson1_1SMSChannelRequest(input.SMSChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateSmsChannelCommand = serializeAws_restJson1_1UpdateSmsChannelCommand;
async function serializeAws_restJson1_1UpdateSmsTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/sms";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.CreateNewVersion !== undefined) {
        query["create-new-version"] = input.CreateNewVersion.toString();
    }
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    if (input.SMSTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1SMSTemplateRequest(input.SMSTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1UpdateSmsTemplateCommand = serializeAws_restJson1_1UpdateSmsTemplateCommand;
async function serializeAws_restJson1_1UpdateTemplateActiveVersionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/{TemplateType}/active-version";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    if (input.TemplateType !== undefined) {
        const labelValue = input.TemplateType;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateType.");
        }
        resolvedPath = resolvedPath.replace("{TemplateType}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateType.");
    }
    let body;
    if (input.TemplateActiveVersionRequest !== undefined) {
        body = serializeAws_restJson1_1TemplateActiveVersionRequest(input.TemplateActiveVersionRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateTemplateActiveVersionCommand = serializeAws_restJson1_1UpdateTemplateActiveVersionCommand;
async function serializeAws_restJson1_1UpdateVoiceChannelCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/apps/{ApplicationId}/channels/voice";
    if (input.ApplicationId !== undefined) {
        const labelValue = input.ApplicationId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ApplicationId.");
        }
        resolvedPath = resolvedPath.replace("{ApplicationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ApplicationId.");
    }
    let body;
    if (input.VoiceChannelRequest !== undefined) {
        body = serializeAws_restJson1_1VoiceChannelRequest(input.VoiceChannelRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1UpdateVoiceChannelCommand = serializeAws_restJson1_1UpdateVoiceChannelCommand;
async function serializeAws_restJson1_1UpdateVoiceTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/templates/{TemplateName}/voice";
    if (input.TemplateName !== undefined) {
        const labelValue = input.TemplateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TemplateName.");
        }
        resolvedPath = resolvedPath.replace("{TemplateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TemplateName.");
    }
    const query = {};
    if (input.CreateNewVersion !== undefined) {
        query["create-new-version"] = input.CreateNewVersion.toString();
    }
    if (input.Version !== undefined) {
        query["version"] = input.Version;
    }
    let body;
    if (input.VoiceTemplateRequest !== undefined) {
        body = serializeAws_restJson1_1VoiceTemplateRequest(input.VoiceTemplateRequest, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1UpdateVoiceTemplateCommand = serializeAws_restJson1_1UpdateVoiceTemplateCommand;
async function deserializeAws_restJson1_1CreateAppCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateAppCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateAppResponse",
        ApplicationResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationResponse = deserializeAws_restJson1_1ApplicationResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateAppCommand = deserializeAws_restJson1_1CreateAppCommand;
async function deserializeAws_restJson1_1CreateAppCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateCampaignCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateCampaignCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateCampaignResponse",
        CampaignResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateCampaignCommand = deserializeAws_restJson1_1CreateCampaignCommand;
async function deserializeAws_restJson1_1CreateCampaignCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateEmailTemplateCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateEmailTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateEmailTemplateResponse",
        CreateTemplateMessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateEmailTemplateCommand = deserializeAws_restJson1_1CreateEmailTemplateCommand;
async function deserializeAws_restJson1_1CreateEmailTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateExportJobCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateExportJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateExportJobResponse",
        ExportJobResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ExportJobResponse = deserializeAws_restJson1_1ExportJobResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateExportJobCommand = deserializeAws_restJson1_1CreateExportJobCommand;
async function deserializeAws_restJson1_1CreateExportJobCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateImportJobCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateImportJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateImportJobResponse",
        ImportJobResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ImportJobResponse = deserializeAws_restJson1_1ImportJobResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateImportJobCommand = deserializeAws_restJson1_1CreateImportJobCommand;
async function deserializeAws_restJson1_1CreateImportJobCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateJourneyCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateJourneyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateJourneyResponse",
        JourneyResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateJourneyCommand = deserializeAws_restJson1_1CreateJourneyCommand;
async function deserializeAws_restJson1_1CreateJourneyCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreatePushTemplateCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreatePushTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreatePushTemplateResponse",
        CreateTemplateMessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreatePushTemplateCommand = deserializeAws_restJson1_1CreatePushTemplateCommand;
async function deserializeAws_restJson1_1CreatePushTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateSegmentCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateSegmentCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateSegmentResponse",
        SegmentResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateSegmentCommand = deserializeAws_restJson1_1CreateSegmentCommand;
async function deserializeAws_restJson1_1CreateSegmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateSmsTemplateCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateSmsTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateSmsTemplateResponse",
        CreateTemplateMessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateSmsTemplateCommand = deserializeAws_restJson1_1CreateSmsTemplateCommand;
async function deserializeAws_restJson1_1CreateSmsTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1CreateVoiceTemplateCommand(output, context) {
    if (output.statusCode !== 201 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1CreateVoiceTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "CreateVoiceTemplateResponse",
        CreateTemplateMessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1CreateVoiceTemplateCommand = deserializeAws_restJson1_1CreateVoiceTemplateCommand;
async function deserializeAws_restJson1_1CreateVoiceTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteAdmChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteAdmChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteAdmChannelResponse",
        ADMChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ADMChannelResponse = deserializeAws_restJson1_1ADMChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteAdmChannelCommand = deserializeAws_restJson1_1DeleteAdmChannelCommand;
async function deserializeAws_restJson1_1DeleteAdmChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteApnsChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteApnsChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteApnsChannelResponse",
        APNSChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSChannelResponse = deserializeAws_restJson1_1APNSChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteApnsChannelCommand = deserializeAws_restJson1_1DeleteApnsChannelCommand;
async function deserializeAws_restJson1_1DeleteApnsChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteApnsSandboxChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteApnsSandboxChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteApnsSandboxChannelResponse",
        APNSSandboxChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSSandboxChannelResponse = deserializeAws_restJson1_1APNSSandboxChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteApnsSandboxChannelCommand = deserializeAws_restJson1_1DeleteApnsSandboxChannelCommand;
async function deserializeAws_restJson1_1DeleteApnsSandboxChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteApnsVoipChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteApnsVoipChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteApnsVoipChannelResponse",
        APNSVoipChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSVoipChannelResponse = deserializeAws_restJson1_1APNSVoipChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteApnsVoipChannelCommand = deserializeAws_restJson1_1DeleteApnsVoipChannelCommand;
async function deserializeAws_restJson1_1DeleteApnsVoipChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteApnsVoipSandboxChannelResponse",
        APNSVoipSandboxChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSVoipSandboxChannelResponse = deserializeAws_restJson1_1APNSVoipSandboxChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand = deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand;
async function deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteAppCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteAppCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteAppResponse",
        ApplicationResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationResponse = deserializeAws_restJson1_1ApplicationResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteAppCommand = deserializeAws_restJson1_1DeleteAppCommand;
async function deserializeAws_restJson1_1DeleteAppCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteBaiduChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteBaiduChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteBaiduChannelResponse",
        BaiduChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.BaiduChannelResponse = deserializeAws_restJson1_1BaiduChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteBaiduChannelCommand = deserializeAws_restJson1_1DeleteBaiduChannelCommand;
async function deserializeAws_restJson1_1DeleteBaiduChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteCampaignCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteCampaignCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteCampaignResponse",
        CampaignResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteCampaignCommand = deserializeAws_restJson1_1DeleteCampaignCommand;
async function deserializeAws_restJson1_1DeleteCampaignCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteEmailChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteEmailChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteEmailChannelResponse",
        EmailChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EmailChannelResponse = deserializeAws_restJson1_1EmailChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteEmailChannelCommand = deserializeAws_restJson1_1DeleteEmailChannelCommand;
async function deserializeAws_restJson1_1DeleteEmailChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteEmailTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteEmailTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteEmailTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteEmailTemplateCommand = deserializeAws_restJson1_1DeleteEmailTemplateCommand;
async function deserializeAws_restJson1_1DeleteEmailTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteEndpointCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteEndpointCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteEndpointResponse",
        EndpointResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EndpointResponse = deserializeAws_restJson1_1EndpointResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteEndpointCommand = deserializeAws_restJson1_1DeleteEndpointCommand;
async function deserializeAws_restJson1_1DeleteEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteEventStreamCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteEventStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteEventStreamResponse",
        EventStream: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EventStream = deserializeAws_restJson1_1EventStream(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteEventStreamCommand = deserializeAws_restJson1_1DeleteEventStreamCommand;
async function deserializeAws_restJson1_1DeleteEventStreamCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteGcmChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteGcmChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteGcmChannelResponse",
        GCMChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.GCMChannelResponse = deserializeAws_restJson1_1GCMChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteGcmChannelCommand = deserializeAws_restJson1_1DeleteGcmChannelCommand;
async function deserializeAws_restJson1_1DeleteGcmChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteJourneyCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteJourneyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteJourneyResponse",
        JourneyResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteJourneyCommand = deserializeAws_restJson1_1DeleteJourneyCommand;
async function deserializeAws_restJson1_1DeleteJourneyCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeletePushTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeletePushTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeletePushTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeletePushTemplateCommand = deserializeAws_restJson1_1DeletePushTemplateCommand;
async function deserializeAws_restJson1_1DeletePushTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteSegmentCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteSegmentCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteSegmentResponse",
        SegmentResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteSegmentCommand = deserializeAws_restJson1_1DeleteSegmentCommand;
async function deserializeAws_restJson1_1DeleteSegmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteSmsChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteSmsChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteSmsChannelResponse",
        SMSChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SMSChannelResponse = deserializeAws_restJson1_1SMSChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteSmsChannelCommand = deserializeAws_restJson1_1DeleteSmsChannelCommand;
async function deserializeAws_restJson1_1DeleteSmsChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteSmsTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteSmsTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteSmsTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteSmsTemplateCommand = deserializeAws_restJson1_1DeleteSmsTemplateCommand;
async function deserializeAws_restJson1_1DeleteSmsTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteUserEndpointsCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteUserEndpointsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteUserEndpointsResponse",
        EndpointsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EndpointsResponse = deserializeAws_restJson1_1EndpointsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteUserEndpointsCommand = deserializeAws_restJson1_1DeleteUserEndpointsCommand;
async function deserializeAws_restJson1_1DeleteUserEndpointsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteVoiceChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteVoiceChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteVoiceChannelResponse",
        VoiceChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.VoiceChannelResponse = deserializeAws_restJson1_1VoiceChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteVoiceChannelCommand = deserializeAws_restJson1_1DeleteVoiceChannelCommand;
async function deserializeAws_restJson1_1DeleteVoiceChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DeleteVoiceTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteVoiceTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteVoiceTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteVoiceTemplateCommand = deserializeAws_restJson1_1DeleteVoiceTemplateCommand;
async function deserializeAws_restJson1_1DeleteVoiceTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetAdmChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetAdmChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetAdmChannelResponse",
        ADMChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ADMChannelResponse = deserializeAws_restJson1_1ADMChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetAdmChannelCommand = deserializeAws_restJson1_1GetAdmChannelCommand;
async function deserializeAws_restJson1_1GetAdmChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetApnsChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetApnsChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetApnsChannelResponse",
        APNSChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSChannelResponse = deserializeAws_restJson1_1APNSChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetApnsChannelCommand = deserializeAws_restJson1_1GetApnsChannelCommand;
async function deserializeAws_restJson1_1GetApnsChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetApnsSandboxChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetApnsSandboxChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetApnsSandboxChannelResponse",
        APNSSandboxChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSSandboxChannelResponse = deserializeAws_restJson1_1APNSSandboxChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetApnsSandboxChannelCommand = deserializeAws_restJson1_1GetApnsSandboxChannelCommand;
async function deserializeAws_restJson1_1GetApnsSandboxChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetApnsVoipChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetApnsVoipChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetApnsVoipChannelResponse",
        APNSVoipChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSVoipChannelResponse = deserializeAws_restJson1_1APNSVoipChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetApnsVoipChannelCommand = deserializeAws_restJson1_1GetApnsVoipChannelCommand;
async function deserializeAws_restJson1_1GetApnsVoipChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetApnsVoipSandboxChannelResponse",
        APNSVoipSandboxChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSVoipSandboxChannelResponse = deserializeAws_restJson1_1APNSVoipSandboxChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommand = deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommand;
async function deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetAppCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetAppCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetAppResponse",
        ApplicationResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationResponse = deserializeAws_restJson1_1ApplicationResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetAppCommand = deserializeAws_restJson1_1GetAppCommand;
async function deserializeAws_restJson1_1GetAppCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetApplicationDateRangeKpiCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetApplicationDateRangeKpiCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetApplicationDateRangeKpiResponse",
        ApplicationDateRangeKpiResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationDateRangeKpiResponse = deserializeAws_restJson1_1ApplicationDateRangeKpiResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetApplicationDateRangeKpiCommand = deserializeAws_restJson1_1GetApplicationDateRangeKpiCommand;
async function deserializeAws_restJson1_1GetApplicationDateRangeKpiCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetApplicationSettingsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetApplicationSettingsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetApplicationSettingsResponse",
        ApplicationSettingsResource: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationSettingsResource = deserializeAws_restJson1_1ApplicationSettingsResource(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetApplicationSettingsCommand = deserializeAws_restJson1_1GetApplicationSettingsCommand;
async function deserializeAws_restJson1_1GetApplicationSettingsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetAppsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetAppsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetAppsResponse",
        ApplicationsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationsResponse = deserializeAws_restJson1_1ApplicationsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetAppsCommand = deserializeAws_restJson1_1GetAppsCommand;
async function deserializeAws_restJson1_1GetAppsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetBaiduChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetBaiduChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetBaiduChannelResponse",
        BaiduChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.BaiduChannelResponse = deserializeAws_restJson1_1BaiduChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetBaiduChannelCommand = deserializeAws_restJson1_1GetBaiduChannelCommand;
async function deserializeAws_restJson1_1GetBaiduChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetCampaignCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetCampaignCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetCampaignResponse",
        CampaignResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetCampaignCommand = deserializeAws_restJson1_1GetCampaignCommand;
async function deserializeAws_restJson1_1GetCampaignCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetCampaignActivitiesCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetCampaignActivitiesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetCampaignActivitiesResponse",
        ActivitiesResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ActivitiesResponse = deserializeAws_restJson1_1ActivitiesResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetCampaignActivitiesCommand = deserializeAws_restJson1_1GetCampaignActivitiesCommand;
async function deserializeAws_restJson1_1GetCampaignActivitiesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetCampaignDateRangeKpiCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetCampaignDateRangeKpiCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetCampaignDateRangeKpiResponse",
        CampaignDateRangeKpiResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignDateRangeKpiResponse = deserializeAws_restJson1_1CampaignDateRangeKpiResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetCampaignDateRangeKpiCommand = deserializeAws_restJson1_1GetCampaignDateRangeKpiCommand;
async function deserializeAws_restJson1_1GetCampaignDateRangeKpiCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetCampaignVersionCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetCampaignVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetCampaignVersionResponse",
        CampaignResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetCampaignVersionCommand = deserializeAws_restJson1_1GetCampaignVersionCommand;
async function deserializeAws_restJson1_1GetCampaignVersionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetCampaignVersionsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetCampaignVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetCampaignVersionsResponse",
        CampaignsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignsResponse = deserializeAws_restJson1_1CampaignsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetCampaignVersionsCommand = deserializeAws_restJson1_1GetCampaignVersionsCommand;
async function deserializeAws_restJson1_1GetCampaignVersionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetCampaignsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetCampaignsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetCampaignsResponse",
        CampaignsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignsResponse = deserializeAws_restJson1_1CampaignsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetCampaignsCommand = deserializeAws_restJson1_1GetCampaignsCommand;
async function deserializeAws_restJson1_1GetCampaignsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetChannelsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetChannelsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetChannelsResponse",
        ChannelsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ChannelsResponse = deserializeAws_restJson1_1ChannelsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetChannelsCommand = deserializeAws_restJson1_1GetChannelsCommand;
async function deserializeAws_restJson1_1GetChannelsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetEmailChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetEmailChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetEmailChannelResponse",
        EmailChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EmailChannelResponse = deserializeAws_restJson1_1EmailChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetEmailChannelCommand = deserializeAws_restJson1_1GetEmailChannelCommand;
async function deserializeAws_restJson1_1GetEmailChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetEmailTemplateCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetEmailTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetEmailTemplateResponse",
        EmailTemplateResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EmailTemplateResponse = deserializeAws_restJson1_1EmailTemplateResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetEmailTemplateCommand = deserializeAws_restJson1_1GetEmailTemplateCommand;
async function deserializeAws_restJson1_1GetEmailTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetEndpointCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetEndpointCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetEndpointResponse",
        EndpointResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EndpointResponse = deserializeAws_restJson1_1EndpointResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetEndpointCommand = deserializeAws_restJson1_1GetEndpointCommand;
async function deserializeAws_restJson1_1GetEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetEventStreamCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetEventStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetEventStreamResponse",
        EventStream: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EventStream = deserializeAws_restJson1_1EventStream(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetEventStreamCommand = deserializeAws_restJson1_1GetEventStreamCommand;
async function deserializeAws_restJson1_1GetEventStreamCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetExportJobCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetExportJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetExportJobResponse",
        ExportJobResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ExportJobResponse = deserializeAws_restJson1_1ExportJobResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetExportJobCommand = deserializeAws_restJson1_1GetExportJobCommand;
async function deserializeAws_restJson1_1GetExportJobCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetExportJobsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetExportJobsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetExportJobsResponse",
        ExportJobsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ExportJobsResponse = deserializeAws_restJson1_1ExportJobsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetExportJobsCommand = deserializeAws_restJson1_1GetExportJobsCommand;
async function deserializeAws_restJson1_1GetExportJobsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetGcmChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetGcmChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetGcmChannelResponse",
        GCMChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.GCMChannelResponse = deserializeAws_restJson1_1GCMChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetGcmChannelCommand = deserializeAws_restJson1_1GetGcmChannelCommand;
async function deserializeAws_restJson1_1GetGcmChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetImportJobCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetImportJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetImportJobResponse",
        ImportJobResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ImportJobResponse = deserializeAws_restJson1_1ImportJobResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetImportJobCommand = deserializeAws_restJson1_1GetImportJobCommand;
async function deserializeAws_restJson1_1GetImportJobCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetImportJobsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetImportJobsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetImportJobsResponse",
        ImportJobsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ImportJobsResponse = deserializeAws_restJson1_1ImportJobsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetImportJobsCommand = deserializeAws_restJson1_1GetImportJobsCommand;
async function deserializeAws_restJson1_1GetImportJobsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetJourneyCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetJourneyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetJourneyResponse",
        JourneyResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetJourneyCommand = deserializeAws_restJson1_1GetJourneyCommand;
async function deserializeAws_restJson1_1GetJourneyCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetJourneyDateRangeKpiCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetJourneyDateRangeKpiCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetJourneyDateRangeKpiResponse",
        JourneyDateRangeKpiResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyDateRangeKpiResponse = deserializeAws_restJson1_1JourneyDateRangeKpiResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetJourneyDateRangeKpiCommand = deserializeAws_restJson1_1GetJourneyDateRangeKpiCommand;
async function deserializeAws_restJson1_1GetJourneyDateRangeKpiCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetJourneyExecutionActivityMetricsResponse",
        JourneyExecutionActivityMetricsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyExecutionActivityMetricsResponse = deserializeAws_restJson1_1JourneyExecutionActivityMetricsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand = deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand;
async function deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetJourneyExecutionMetricsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetJourneyExecutionMetricsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetJourneyExecutionMetricsResponse",
        JourneyExecutionMetricsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyExecutionMetricsResponse = deserializeAws_restJson1_1JourneyExecutionMetricsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetJourneyExecutionMetricsCommand = deserializeAws_restJson1_1GetJourneyExecutionMetricsCommand;
async function deserializeAws_restJson1_1GetJourneyExecutionMetricsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetPushTemplateCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetPushTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetPushTemplateResponse",
        PushNotificationTemplateResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.PushNotificationTemplateResponse = deserializeAws_restJson1_1PushNotificationTemplateResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetPushTemplateCommand = deserializeAws_restJson1_1GetPushTemplateCommand;
async function deserializeAws_restJson1_1GetPushTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSegmentCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSegmentCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSegmentResponse",
        SegmentResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSegmentCommand = deserializeAws_restJson1_1GetSegmentCommand;
async function deserializeAws_restJson1_1GetSegmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSegmentExportJobsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSegmentExportJobsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSegmentExportJobsResponse",
        ExportJobsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ExportJobsResponse = deserializeAws_restJson1_1ExportJobsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSegmentExportJobsCommand = deserializeAws_restJson1_1GetSegmentExportJobsCommand;
async function deserializeAws_restJson1_1GetSegmentExportJobsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSegmentImportJobsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSegmentImportJobsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSegmentImportJobsResponse",
        ImportJobsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ImportJobsResponse = deserializeAws_restJson1_1ImportJobsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSegmentImportJobsCommand = deserializeAws_restJson1_1GetSegmentImportJobsCommand;
async function deserializeAws_restJson1_1GetSegmentImportJobsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSegmentVersionCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSegmentVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSegmentVersionResponse",
        SegmentResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSegmentVersionCommand = deserializeAws_restJson1_1GetSegmentVersionCommand;
async function deserializeAws_restJson1_1GetSegmentVersionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSegmentVersionsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSegmentVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSegmentVersionsResponse",
        SegmentsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentsResponse = deserializeAws_restJson1_1SegmentsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSegmentVersionsCommand = deserializeAws_restJson1_1GetSegmentVersionsCommand;
async function deserializeAws_restJson1_1GetSegmentVersionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSegmentsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSegmentsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSegmentsResponse",
        SegmentsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentsResponse = deserializeAws_restJson1_1SegmentsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSegmentsCommand = deserializeAws_restJson1_1GetSegmentsCommand;
async function deserializeAws_restJson1_1GetSegmentsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSmsChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSmsChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSmsChannelResponse",
        SMSChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SMSChannelResponse = deserializeAws_restJson1_1SMSChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSmsChannelCommand = deserializeAws_restJson1_1GetSmsChannelCommand;
async function deserializeAws_restJson1_1GetSmsChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSmsTemplateCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSmsTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSmsTemplateResponse",
        SMSTemplateResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SMSTemplateResponse = deserializeAws_restJson1_1SMSTemplateResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSmsTemplateCommand = deserializeAws_restJson1_1GetSmsTemplateCommand;
async function deserializeAws_restJson1_1GetSmsTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetUserEndpointsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetUserEndpointsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetUserEndpointsResponse",
        EndpointsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EndpointsResponse = deserializeAws_restJson1_1EndpointsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetUserEndpointsCommand = deserializeAws_restJson1_1GetUserEndpointsCommand;
async function deserializeAws_restJson1_1GetUserEndpointsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetVoiceChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetVoiceChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetVoiceChannelResponse",
        VoiceChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.VoiceChannelResponse = deserializeAws_restJson1_1VoiceChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetVoiceChannelCommand = deserializeAws_restJson1_1GetVoiceChannelCommand;
async function deserializeAws_restJson1_1GetVoiceChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetVoiceTemplateCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetVoiceTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetVoiceTemplateResponse",
        VoiceTemplateResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.VoiceTemplateResponse = deserializeAws_restJson1_1VoiceTemplateResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetVoiceTemplateCommand = deserializeAws_restJson1_1GetVoiceTemplateCommand;
async function deserializeAws_restJson1_1GetVoiceTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1ListJourneysCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1ListJourneysCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "ListJourneysResponse",
        JourneysResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneysResponse = deserializeAws_restJson1_1JourneysResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1ListJourneysCommand = deserializeAws_restJson1_1ListJourneysCommand;
async function deserializeAws_restJson1_1ListJourneysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1ListTagsForResourceCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1ListTagsForResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "ListTagsForResourceResponse",
        TagsModel: undefined
    };
    const data = await parseBody(output.body, context);
    contents.TagsModel = deserializeAws_restJson1_1TagsModel(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1ListTagsForResourceCommand = deserializeAws_restJson1_1ListTagsForResourceCommand;
async function deserializeAws_restJson1_1ListTagsForResourceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1ListTemplateVersionsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1ListTemplateVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "ListTemplateVersionsResponse",
        TemplateVersionsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.TemplateVersionsResponse = deserializeAws_restJson1_1TemplateVersionsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1ListTemplateVersionsCommand = deserializeAws_restJson1_1ListTemplateVersionsCommand;
async function deserializeAws_restJson1_1ListTemplateVersionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1ListTemplatesCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1ListTemplatesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "ListTemplatesResponse",
        TemplatesResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.TemplatesResponse = deserializeAws_restJson1_1TemplatesResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1ListTemplatesCommand = deserializeAws_restJson1_1ListTemplatesCommand;
async function deserializeAws_restJson1_1ListTemplatesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1PhoneNumberValidateCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1PhoneNumberValidateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "PhoneNumberValidateResponse",
        NumberValidateResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.NumberValidateResponse = deserializeAws_restJson1_1NumberValidateResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1PhoneNumberValidateCommand = deserializeAws_restJson1_1PhoneNumberValidateCommand;
async function deserializeAws_restJson1_1PhoneNumberValidateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1PutEventStreamCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1PutEventStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "PutEventStreamResponse",
        EventStream: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EventStream = deserializeAws_restJson1_1EventStream(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1PutEventStreamCommand = deserializeAws_restJson1_1PutEventStreamCommand;
async function deserializeAws_restJson1_1PutEventStreamCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1PutEventsCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1PutEventsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "PutEventsResponse",
        EventsResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EventsResponse = deserializeAws_restJson1_1EventsResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1PutEventsCommand = deserializeAws_restJson1_1PutEventsCommand;
async function deserializeAws_restJson1_1PutEventsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1RemoveAttributesCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1RemoveAttributesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "RemoveAttributesResponse",
        AttributesResource: undefined
    };
    const data = await parseBody(output.body, context);
    contents.AttributesResource = deserializeAws_restJson1_1AttributesResource(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1RemoveAttributesCommand = deserializeAws_restJson1_1RemoveAttributesCommand;
async function deserializeAws_restJson1_1RemoveAttributesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1SendMessagesCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1SendMessagesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "SendMessagesResponse",
        MessageResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageResponse = deserializeAws_restJson1_1MessageResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1SendMessagesCommand = deserializeAws_restJson1_1SendMessagesCommand;
async function deserializeAws_restJson1_1SendMessagesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1SendUsersMessagesCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1SendUsersMessagesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "SendUsersMessagesResponse",
        SendUsersMessageResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SendUsersMessageResponse = deserializeAws_restJson1_1SendUsersMessageResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1SendUsersMessagesCommand = deserializeAws_restJson1_1SendUsersMessagesCommand;
async function deserializeAws_restJson1_1SendUsersMessagesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1TagResourceCommand(output, context) {
    if (output.statusCode !== 204 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1TagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output)
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1TagResourceCommand = deserializeAws_restJson1_1TagResourceCommand;
async function deserializeAws_restJson1_1TagResourceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UntagResourceCommand(output, context) {
    if (output.statusCode !== 204 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UntagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output)
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UntagResourceCommand = deserializeAws_restJson1_1UntagResourceCommand;
async function deserializeAws_restJson1_1UntagResourceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateAdmChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateAdmChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateAdmChannelResponse",
        ADMChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ADMChannelResponse = deserializeAws_restJson1_1ADMChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateAdmChannelCommand = deserializeAws_restJson1_1UpdateAdmChannelCommand;
async function deserializeAws_restJson1_1UpdateAdmChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateApnsChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateApnsChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateApnsChannelResponse",
        APNSChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSChannelResponse = deserializeAws_restJson1_1APNSChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateApnsChannelCommand = deserializeAws_restJson1_1UpdateApnsChannelCommand;
async function deserializeAws_restJson1_1UpdateApnsChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateApnsSandboxChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateApnsSandboxChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateApnsSandboxChannelResponse",
        APNSSandboxChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSSandboxChannelResponse = deserializeAws_restJson1_1APNSSandboxChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateApnsSandboxChannelCommand = deserializeAws_restJson1_1UpdateApnsSandboxChannelCommand;
async function deserializeAws_restJson1_1UpdateApnsSandboxChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateApnsVoipChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateApnsVoipChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateApnsVoipChannelResponse",
        APNSVoipChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSVoipChannelResponse = deserializeAws_restJson1_1APNSVoipChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateApnsVoipChannelCommand = deserializeAws_restJson1_1UpdateApnsVoipChannelCommand;
async function deserializeAws_restJson1_1UpdateApnsVoipChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateApnsVoipSandboxChannelResponse",
        APNSVoipSandboxChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.APNSVoipSandboxChannelResponse = deserializeAws_restJson1_1APNSVoipSandboxChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand = deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand;
async function deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateApplicationSettingsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateApplicationSettingsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateApplicationSettingsResponse",
        ApplicationSettingsResource: undefined
    };
    const data = await parseBody(output.body, context);
    contents.ApplicationSettingsResource = deserializeAws_restJson1_1ApplicationSettingsResource(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateApplicationSettingsCommand = deserializeAws_restJson1_1UpdateApplicationSettingsCommand;
async function deserializeAws_restJson1_1UpdateApplicationSettingsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateBaiduChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateBaiduChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateBaiduChannelResponse",
        BaiduChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.BaiduChannelResponse = deserializeAws_restJson1_1BaiduChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateBaiduChannelCommand = deserializeAws_restJson1_1UpdateBaiduChannelCommand;
async function deserializeAws_restJson1_1UpdateBaiduChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateCampaignCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateCampaignCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateCampaignResponse",
        CampaignResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateCampaignCommand = deserializeAws_restJson1_1UpdateCampaignCommand;
async function deserializeAws_restJson1_1UpdateCampaignCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateEmailChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateEmailChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateEmailChannelResponse",
        EmailChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.EmailChannelResponse = deserializeAws_restJson1_1EmailChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateEmailChannelCommand = deserializeAws_restJson1_1UpdateEmailChannelCommand;
async function deserializeAws_restJson1_1UpdateEmailChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateEmailTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateEmailTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateEmailTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateEmailTemplateCommand = deserializeAws_restJson1_1UpdateEmailTemplateCommand;
async function deserializeAws_restJson1_1UpdateEmailTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateEndpointCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateEndpointCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateEndpointResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateEndpointCommand = deserializeAws_restJson1_1UpdateEndpointCommand;
async function deserializeAws_restJson1_1UpdateEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateEndpointsBatchCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateEndpointsBatchCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateEndpointsBatchResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateEndpointsBatchCommand = deserializeAws_restJson1_1UpdateEndpointsBatchCommand;
async function deserializeAws_restJson1_1UpdateEndpointsBatchCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateGcmChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateGcmChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateGcmChannelResponse",
        GCMChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.GCMChannelResponse = deserializeAws_restJson1_1GCMChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateGcmChannelCommand = deserializeAws_restJson1_1UpdateGcmChannelCommand;
async function deserializeAws_restJson1_1UpdateGcmChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateJourneyCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateJourneyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateJourneyResponse",
        JourneyResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateJourneyCommand = deserializeAws_restJson1_1UpdateJourneyCommand;
async function deserializeAws_restJson1_1UpdateJourneyCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateJourneyStateCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateJourneyStateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateJourneyStateResponse",
        JourneyResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateJourneyStateCommand = deserializeAws_restJson1_1UpdateJourneyStateCommand;
async function deserializeAws_restJson1_1UpdateJourneyStateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdatePushTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdatePushTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdatePushTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdatePushTemplateCommand = deserializeAws_restJson1_1UpdatePushTemplateCommand;
async function deserializeAws_restJson1_1UpdatePushTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateSegmentCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateSegmentCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateSegmentResponse",
        SegmentResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateSegmentCommand = deserializeAws_restJson1_1UpdateSegmentCommand;
async function deserializeAws_restJson1_1UpdateSegmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateSmsChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateSmsChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateSmsChannelResponse",
        SMSChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.SMSChannelResponse = deserializeAws_restJson1_1SMSChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateSmsChannelCommand = deserializeAws_restJson1_1UpdateSmsChannelCommand;
async function deserializeAws_restJson1_1UpdateSmsChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateSmsTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateSmsTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateSmsTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateSmsTemplateCommand = deserializeAws_restJson1_1UpdateSmsTemplateCommand;
async function deserializeAws_restJson1_1UpdateSmsTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateTemplateActiveVersionCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateTemplateActiveVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateTemplateActiveVersionResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateTemplateActiveVersionCommand = deserializeAws_restJson1_1UpdateTemplateActiveVersionCommand;
async function deserializeAws_restJson1_1UpdateTemplateActiveVersionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateVoiceChannelCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateVoiceChannelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateVoiceChannelResponse",
        VoiceChannelResponse: undefined
    };
    const data = await parseBody(output.body, context);
    contents.VoiceChannelResponse = deserializeAws_restJson1_1VoiceChannelResponse(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateVoiceChannelCommand = deserializeAws_restJson1_1UpdateVoiceChannelCommand;
async function deserializeAws_restJson1_1UpdateVoiceChannelCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1UpdateVoiceTemplateCommand(output, context) {
    if (output.statusCode !== 202 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1UpdateVoiceTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "UpdateVoiceTemplateResponse",
        MessageBody: undefined
    };
    const data = await parseBody(output.body, context);
    contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1UpdateVoiceTemplateCommand = deserializeAws_restJson1_1UpdateVoiceTemplateCommand;
async function deserializeAws_restJson1_1UpdateVoiceTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.pinpoint#BadRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ForbiddenException":
        case "com.amazonaws.pinpoint#ForbiddenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ForbiddenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerErrorException":
        case "com.amazonaws.pinpoint#InternalServerErrorException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MethodNotAllowedException":
        case "com.amazonaws.pinpoint#MethodNotAllowedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "NotFoundException":
        case "com.amazonaws.pinpoint#NotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.pinpoint#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
const deserializeAws_restJson1_1BadRequestExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "BadRequestException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        Message: undefined,
        RequestID: undefined
    };
    const data = parsedOutput.body;
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = data.Message;
    }
    if (data.RequestID !== undefined && data.RequestID !== null) {
        contents.RequestID = data.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1ForbiddenExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ForbiddenException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        Message: undefined,
        RequestID: undefined
    };
    const data = parsedOutput.body;
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = data.Message;
    }
    if (data.RequestID !== undefined && data.RequestID !== null) {
        contents.RequestID = data.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1InternalServerErrorExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InternalServerErrorException",
        $fault: "server",
        $metadata: deserializeMetadata(parsedOutput),
        Message: undefined,
        RequestID: undefined
    };
    const data = parsedOutput.body;
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = data.Message;
    }
    if (data.RequestID !== undefined && data.RequestID !== null) {
        contents.RequestID = data.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1MethodNotAllowedExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "MethodNotAllowedException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        Message: undefined,
        RequestID: undefined
    };
    const data = parsedOutput.body;
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = data.Message;
    }
    if (data.RequestID !== undefined && data.RequestID !== null) {
        contents.RequestID = data.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1NotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "NotFoundException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        Message: undefined,
        RequestID: undefined
    };
    const data = parsedOutput.body;
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = data.Message;
    }
    if (data.RequestID !== undefined && data.RequestID !== null) {
        contents.RequestID = data.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "TooManyRequestsException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        Message: undefined,
        RequestID: undefined
    };
    const data = parsedOutput.body;
    if (data.Message !== undefined && data.Message !== null) {
        contents.Message = data.Message;
    }
    if (data.RequestID !== undefined && data.RequestID !== null) {
        contents.RequestID = data.RequestID;
    }
    return contents;
};
const serializeAws_restJson1_1ADMChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.ClientId !== undefined) {
        bodyParams["ClientId"] = input.ClientId;
    }
    if (input.ClientSecret !== undefined) {
        bodyParams["ClientSecret"] = input.ClientSecret;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    return bodyParams;
};
const serializeAws_restJson1_1ADMMessage = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.ConsolidationKey !== undefined) {
        bodyParams["ConsolidationKey"] = input.ConsolidationKey;
    }
    if (input.Data !== undefined) {
        bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(input.Data, context);
    }
    if (input.ExpiresAfter !== undefined) {
        bodyParams["ExpiresAfter"] = input.ExpiresAfter;
    }
    if (input.IconReference !== undefined) {
        bodyParams["IconReference"] = input.IconReference;
    }
    if (input.ImageIconUrl !== undefined) {
        bodyParams["ImageIconUrl"] = input.ImageIconUrl;
    }
    if (input.ImageUrl !== undefined) {
        bodyParams["ImageUrl"] = input.ImageUrl;
    }
    if (input.MD5 !== undefined) {
        bodyParams["MD5"] = input.MD5;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.SilentPush !== undefined) {
        bodyParams["SilentPush"] = input.SilentPush;
    }
    if (input.SmallImageIconUrl !== undefined) {
        bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1APNSChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.BundleId !== undefined) {
        bodyParams["BundleId"] = input.BundleId;
    }
    if (input.Certificate !== undefined) {
        bodyParams["Certificate"] = input.Certificate;
    }
    if (input.DefaultAuthenticationMethod !== undefined) {
        bodyParams["DefaultAuthenticationMethod"] =
            input.DefaultAuthenticationMethod;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.PrivateKey !== undefined) {
        bodyParams["PrivateKey"] = input.PrivateKey;
    }
    if (input.TeamId !== undefined) {
        bodyParams["TeamId"] = input.TeamId;
    }
    if (input.TokenKey !== undefined) {
        bodyParams["TokenKey"] = input.TokenKey;
    }
    if (input.TokenKeyId !== undefined) {
        bodyParams["TokenKeyId"] = input.TokenKeyId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1APNSMessage = (input, context) => {
    const bodyParams = {};
    if (input.APNSPushType !== undefined) {
        bodyParams["APNSPushType"] = input.APNSPushType;
    }
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Badge !== undefined) {
        bodyParams["Badge"] = input.Badge;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.Category !== undefined) {
        bodyParams["Category"] = input.Category;
    }
    if (input.CollapseId !== undefined) {
        bodyParams["CollapseId"] = input.CollapseId;
    }
    if (input.Data !== undefined) {
        bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(input.Data, context);
    }
    if (input.MediaUrl !== undefined) {
        bodyParams["MediaUrl"] = input.MediaUrl;
    }
    if (input.PreferredAuthenticationMethod !== undefined) {
        bodyParams["PreferredAuthenticationMethod"] =
            input.PreferredAuthenticationMethod;
    }
    if (input.Priority !== undefined) {
        bodyParams["Priority"] = input.Priority;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.SilentPush !== undefined) {
        bodyParams["SilentPush"] = input.SilentPush;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.ThreadId !== undefined) {
        bodyParams["ThreadId"] = input.ThreadId;
    }
    if (input.TimeToLive !== undefined) {
        bodyParams["TimeToLive"] = input.TimeToLive;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1APNSPushNotificationTemplate = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.MediaUrl !== undefined) {
        bodyParams["MediaUrl"] = input.MediaUrl;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1APNSSandboxChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.BundleId !== undefined) {
        bodyParams["BundleId"] = input.BundleId;
    }
    if (input.Certificate !== undefined) {
        bodyParams["Certificate"] = input.Certificate;
    }
    if (input.DefaultAuthenticationMethod !== undefined) {
        bodyParams["DefaultAuthenticationMethod"] =
            input.DefaultAuthenticationMethod;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.PrivateKey !== undefined) {
        bodyParams["PrivateKey"] = input.PrivateKey;
    }
    if (input.TeamId !== undefined) {
        bodyParams["TeamId"] = input.TeamId;
    }
    if (input.TokenKey !== undefined) {
        bodyParams["TokenKey"] = input.TokenKey;
    }
    if (input.TokenKeyId !== undefined) {
        bodyParams["TokenKeyId"] = input.TokenKeyId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1APNSVoipChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.BundleId !== undefined) {
        bodyParams["BundleId"] = input.BundleId;
    }
    if (input.Certificate !== undefined) {
        bodyParams["Certificate"] = input.Certificate;
    }
    if (input.DefaultAuthenticationMethod !== undefined) {
        bodyParams["DefaultAuthenticationMethod"] =
            input.DefaultAuthenticationMethod;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.PrivateKey !== undefined) {
        bodyParams["PrivateKey"] = input.PrivateKey;
    }
    if (input.TeamId !== undefined) {
        bodyParams["TeamId"] = input.TeamId;
    }
    if (input.TokenKey !== undefined) {
        bodyParams["TokenKey"] = input.TokenKey;
    }
    if (input.TokenKeyId !== undefined) {
        bodyParams["TokenKeyId"] = input.TokenKeyId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1APNSVoipSandboxChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.BundleId !== undefined) {
        bodyParams["BundleId"] = input.BundleId;
    }
    if (input.Certificate !== undefined) {
        bodyParams["Certificate"] = input.Certificate;
    }
    if (input.DefaultAuthenticationMethod !== undefined) {
        bodyParams["DefaultAuthenticationMethod"] =
            input.DefaultAuthenticationMethod;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.PrivateKey !== undefined) {
        bodyParams["PrivateKey"] = input.PrivateKey;
    }
    if (input.TeamId !== undefined) {
        bodyParams["TeamId"] = input.TeamId;
    }
    if (input.TokenKey !== undefined) {
        bodyParams["TokenKey"] = input.TokenKey;
    }
    if (input.TokenKeyId !== undefined) {
        bodyParams["TokenKeyId"] = input.TokenKeyId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1Activity = (input, context) => {
    const bodyParams = {};
    if (input.ConditionalSplit !== undefined) {
        bodyParams["ConditionalSplit"] = serializeAws_restJson1_1ConditionalSplitActivity(input.ConditionalSplit, context);
    }
    if (input.Description !== undefined) {
        bodyParams["Description"] = input.Description;
    }
    if (input.EMAIL !== undefined) {
        bodyParams["EMAIL"] = serializeAws_restJson1_1EmailMessageActivity(input.EMAIL, context);
    }
    if (input.Holdout !== undefined) {
        bodyParams["Holdout"] = serializeAws_restJson1_1HoldoutActivity(input.Holdout, context);
    }
    if (input.MultiCondition !== undefined) {
        bodyParams["MultiCondition"] = serializeAws_restJson1_1MultiConditionalSplitActivity(input.MultiCondition, context);
    }
    if (input.RandomSplit !== undefined) {
        bodyParams["RandomSplit"] = serializeAws_restJson1_1RandomSplitActivity(input.RandomSplit, context);
    }
    if (input.Wait !== undefined) {
        bodyParams["Wait"] = serializeAws_restJson1_1WaitActivity(input.Wait, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1AddressConfiguration = (input, context) => {
    const bodyParams = {};
    if (input.BodyOverride !== undefined) {
        bodyParams["BodyOverride"] = input.BodyOverride;
    }
    if (input.ChannelType !== undefined) {
        bodyParams["ChannelType"] = input.ChannelType;
    }
    if (input.Context !== undefined) {
        bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(input.Context, context);
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.TitleOverride !== undefined) {
        bodyParams["TitleOverride"] = input.TitleOverride;
    }
    return bodyParams;
};
const serializeAws_restJson1_1AndroidPushNotificationTemplate = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.ImageIconUrl !== undefined) {
        bodyParams["ImageIconUrl"] = input.ImageIconUrl;
    }
    if (input.ImageUrl !== undefined) {
        bodyParams["ImageUrl"] = input.ImageUrl;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.SmallImageIconUrl !== undefined) {
        bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1AttributeDimension = (input, context) => {
    const bodyParams = {};
    if (input.AttributeType !== undefined) {
        bodyParams["AttributeType"] = input.AttributeType;
    }
    if (input.Values !== undefined) {
        bodyParams["Values"] = serializeAws_restJson1_1ListOf__string(input.Values, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1BaiduChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.ApiKey !== undefined) {
        bodyParams["ApiKey"] = input.ApiKey;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.SecretKey !== undefined) {
        bodyParams["SecretKey"] = input.SecretKey;
    }
    return bodyParams;
};
const serializeAws_restJson1_1BaiduMessage = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.Data !== undefined) {
        bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(input.Data, context);
    }
    if (input.IconReference !== undefined) {
        bodyParams["IconReference"] = input.IconReference;
    }
    if (input.ImageIconUrl !== undefined) {
        bodyParams["ImageIconUrl"] = input.ImageIconUrl;
    }
    if (input.ImageUrl !== undefined) {
        bodyParams["ImageUrl"] = input.ImageUrl;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.SilentPush !== undefined) {
        bodyParams["SilentPush"] = input.SilentPush;
    }
    if (input.SmallImageIconUrl !== undefined) {
        bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.TimeToLive !== undefined) {
        bodyParams["TimeToLive"] = input.TimeToLive;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1CampaignEmailMessage = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.FromAddress !== undefined) {
        bodyParams["FromAddress"] = input.FromAddress;
    }
    if (input.HtmlBody !== undefined) {
        bodyParams["HtmlBody"] = input.HtmlBody;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    return bodyParams;
};
const serializeAws_restJson1_1CampaignEventFilter = (input, context) => {
    const bodyParams = {};
    if (input.Dimensions !== undefined) {
        bodyParams["Dimensions"] = serializeAws_restJson1_1EventDimensions(input.Dimensions, context);
    }
    if (input.FilterType !== undefined) {
        bodyParams["FilterType"] = input.FilterType;
    }
    return bodyParams;
};
const serializeAws_restJson1_1CampaignHook = (input, context) => {
    const bodyParams = {};
    if (input.LambdaFunctionName !== undefined) {
        bodyParams["LambdaFunctionName"] = input.LambdaFunctionName;
    }
    if (input.Mode !== undefined) {
        bodyParams["Mode"] = input.Mode;
    }
    if (input.WebUrl !== undefined) {
        bodyParams["WebUrl"] = input.WebUrl;
    }
    return bodyParams;
};
const serializeAws_restJson1_1CampaignLimits = (input, context) => {
    const bodyParams = {};
    if (input.Daily !== undefined) {
        bodyParams["Daily"] = input.Daily;
    }
    if (input.MaximumDuration !== undefined) {
        bodyParams["MaximumDuration"] = input.MaximumDuration;
    }
    if (input.MessagesPerSecond !== undefined) {
        bodyParams["MessagesPerSecond"] = input.MessagesPerSecond;
    }
    if (input.Total !== undefined) {
        bodyParams["Total"] = input.Total;
    }
    return bodyParams;
};
const serializeAws_restJson1_1CampaignSmsMessage = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.MessageType !== undefined) {
        bodyParams["MessageType"] = input.MessageType;
    }
    if (input.SenderId !== undefined) {
        bodyParams["SenderId"] = input.SenderId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1Condition = (input, context) => {
    const bodyParams = {};
    if (input.Conditions !== undefined) {
        bodyParams["Conditions"] = serializeAws_restJson1_1ListOfSimpleCondition(input.Conditions, context);
    }
    if (input.Operator !== undefined) {
        bodyParams["Operator"] = input.Operator;
    }
    return bodyParams;
};
const serializeAws_restJson1_1ConditionalSplitActivity = (input, context) => {
    const bodyParams = {};
    if (input.Condition !== undefined) {
        bodyParams["Condition"] = serializeAws_restJson1_1Condition(input.Condition, context);
    }
    if (input.EvaluationWaitTime !== undefined) {
        bodyParams["EvaluationWaitTime"] = serializeAws_restJson1_1WaitTime(input.EvaluationWaitTime, context);
    }
    if (input.FalseActivity !== undefined) {
        bodyParams["FalseActivity"] = input.FalseActivity;
    }
    if (input.TrueActivity !== undefined) {
        bodyParams["TrueActivity"] = input.TrueActivity;
    }
    return bodyParams;
};
const serializeAws_restJson1_1CreateApplicationRequest = (input, context) => {
    const bodyParams = {};
    if (input.Name !== undefined) {
        bodyParams["Name"] = input.Name;
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1DefaultMessage = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1DefaultPushNotificationMessage = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.Data !== undefined) {
        bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(input.Data, context);
    }
    if (input.SilentPush !== undefined) {
        bodyParams["SilentPush"] = input.SilentPush;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1DefaultPushNotificationTemplate = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1DirectMessageConfiguration = (input, context) => {
    const bodyParams = {};
    if (input.ADMMessage !== undefined) {
        bodyParams["ADMMessage"] = serializeAws_restJson1_1ADMMessage(input.ADMMessage, context);
    }
    if (input.APNSMessage !== undefined) {
        bodyParams["APNSMessage"] = serializeAws_restJson1_1APNSMessage(input.APNSMessage, context);
    }
    if (input.BaiduMessage !== undefined) {
        bodyParams["BaiduMessage"] = serializeAws_restJson1_1BaiduMessage(input.BaiduMessage, context);
    }
    if (input.DefaultMessage !== undefined) {
        bodyParams["DefaultMessage"] = serializeAws_restJson1_1DefaultMessage(input.DefaultMessage, context);
    }
    if (input.DefaultPushNotificationMessage !== undefined) {
        bodyParams["DefaultPushNotificationMessage"] = serializeAws_restJson1_1DefaultPushNotificationMessage(input.DefaultPushNotificationMessage, context);
    }
    if (input.EmailMessage !== undefined) {
        bodyParams["EmailMessage"] = serializeAws_restJson1_1EmailMessage(input.EmailMessage, context);
    }
    if (input.GCMMessage !== undefined) {
        bodyParams["GCMMessage"] = serializeAws_restJson1_1GCMMessage(input.GCMMessage, context);
    }
    if (input.SMSMessage !== undefined) {
        bodyParams["SMSMessage"] = serializeAws_restJson1_1SMSMessage(input.SMSMessage, context);
    }
    if (input.VoiceMessage !== undefined) {
        bodyParams["VoiceMessage"] = serializeAws_restJson1_1VoiceMessage(input.VoiceMessage, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EmailChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.ConfigurationSet !== undefined) {
        bodyParams["ConfigurationSet"] = input.ConfigurationSet;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.FromAddress !== undefined) {
        bodyParams["FromAddress"] = input.FromAddress;
    }
    if (input.Identity !== undefined) {
        bodyParams["Identity"] = input.Identity;
    }
    if (input.RoleArn !== undefined) {
        bodyParams["RoleArn"] = input.RoleArn;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EmailMessage = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.FeedbackForwardingAddress !== undefined) {
        bodyParams["FeedbackForwardingAddress"] = input.FeedbackForwardingAddress;
    }
    if (input.FromAddress !== undefined) {
        bodyParams["FromAddress"] = input.FromAddress;
    }
    if (input.RawEmail !== undefined) {
        bodyParams["RawEmail"] = serializeAws_restJson1_1RawEmail(input.RawEmail, context);
    }
    if (input.ReplyToAddresses !== undefined) {
        bodyParams["ReplyToAddresses"] = serializeAws_restJson1_1ListOf__string(input.ReplyToAddresses, context);
    }
    if (input.SimpleEmail !== undefined) {
        bodyParams["SimpleEmail"] = serializeAws_restJson1_1SimpleEmail(input.SimpleEmail, context);
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EmailMessageActivity = (input, context) => {
    const bodyParams = {};
    if (input.MessageConfig !== undefined) {
        bodyParams["MessageConfig"] = serializeAws_restJson1_1JourneyEmailMessage(input.MessageConfig, context);
    }
    if (input.NextActivity !== undefined) {
        bodyParams["NextActivity"] = input.NextActivity;
    }
    if (input.TemplateName !== undefined) {
        bodyParams["TemplateName"] = input.TemplateName;
    }
    if (input.TemplateVersion !== undefined) {
        bodyParams["TemplateVersion"] = input.TemplateVersion;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EmailTemplateRequest = (input, context) => {
    const bodyParams = {};
    if (input.DefaultSubstitutions !== undefined) {
        bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
    }
    if (input.HtmlPart !== undefined) {
        bodyParams["HtmlPart"] = input.HtmlPart;
    }
    if (input.Subject !== undefined) {
        bodyParams["Subject"] = input.Subject;
    }
    if (input.TemplateDescription !== undefined) {
        bodyParams["TemplateDescription"] = input.TemplateDescription;
    }
    if (input.TextPart !== undefined) {
        bodyParams["TextPart"] = input.TextPart;
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointBatchItem = (input, context) => {
    const bodyParams = {};
    if (input.Address !== undefined) {
        bodyParams["Address"] = input.Address;
    }
    if (input.Attributes !== undefined) {
        bodyParams["Attributes"] = serializeAws_restJson1_1MapOfListOf__string(input.Attributes, context);
    }
    if (input.ChannelType !== undefined) {
        bodyParams["ChannelType"] = input.ChannelType;
    }
    if (input.Demographic !== undefined) {
        bodyParams["Demographic"] = serializeAws_restJson1_1EndpointDemographic(input.Demographic, context);
    }
    if (input.EffectiveDate !== undefined) {
        bodyParams["EffectiveDate"] = input.EffectiveDate;
    }
    if (input.EndpointStatus !== undefined) {
        bodyParams["EndpointStatus"] = input.EndpointStatus;
    }
    if (input.Id !== undefined) {
        bodyParams["Id"] = input.Id;
    }
    if (input.Location !== undefined) {
        bodyParams["Location"] = serializeAws_restJson1_1EndpointLocation(input.Location, context);
    }
    if (input.Metrics !== undefined) {
        bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(input.Metrics, context);
    }
    if (input.OptOut !== undefined) {
        bodyParams["OptOut"] = input.OptOut;
    }
    if (input.RequestId !== undefined) {
        bodyParams["RequestId"] = input.RequestId;
    }
    if (input.User !== undefined) {
        bodyParams["User"] = serializeAws_restJson1_1EndpointUser(input.User, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointBatchRequest = (input, context) => {
    const bodyParams = {};
    if (input.Item !== undefined) {
        bodyParams["Item"] = serializeAws_restJson1_1ListOfEndpointBatchItem(input.Item, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointDemographic = (input, context) => {
    const bodyParams = {};
    if (input.AppVersion !== undefined) {
        bodyParams["AppVersion"] = input.AppVersion;
    }
    if (input.Locale !== undefined) {
        bodyParams["Locale"] = input.Locale;
    }
    if (input.Make !== undefined) {
        bodyParams["Make"] = input.Make;
    }
    if (input.Model !== undefined) {
        bodyParams["Model"] = input.Model;
    }
    if (input.ModelVersion !== undefined) {
        bodyParams["ModelVersion"] = input.ModelVersion;
    }
    if (input.Platform !== undefined) {
        bodyParams["Platform"] = input.Platform;
    }
    if (input.PlatformVersion !== undefined) {
        bodyParams["PlatformVersion"] = input.PlatformVersion;
    }
    if (input.Timezone !== undefined) {
        bodyParams["Timezone"] = input.Timezone;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointLocation = (input, context) => {
    const bodyParams = {};
    if (input.City !== undefined) {
        bodyParams["City"] = input.City;
    }
    if (input.Country !== undefined) {
        bodyParams["Country"] = input.Country;
    }
    if (input.Latitude !== undefined) {
        bodyParams["Latitude"] = input.Latitude;
    }
    if (input.Longitude !== undefined) {
        bodyParams["Longitude"] = input.Longitude;
    }
    if (input.PostalCode !== undefined) {
        bodyParams["PostalCode"] = input.PostalCode;
    }
    if (input.Region !== undefined) {
        bodyParams["Region"] = input.Region;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointRequest = (input, context) => {
    const bodyParams = {};
    if (input.Address !== undefined) {
        bodyParams["Address"] = input.Address;
    }
    if (input.Attributes !== undefined) {
        bodyParams["Attributes"] = serializeAws_restJson1_1MapOfListOf__string(input.Attributes, context);
    }
    if (input.ChannelType !== undefined) {
        bodyParams["ChannelType"] = input.ChannelType;
    }
    if (input.Demographic !== undefined) {
        bodyParams["Demographic"] = serializeAws_restJson1_1EndpointDemographic(input.Demographic, context);
    }
    if (input.EffectiveDate !== undefined) {
        bodyParams["EffectiveDate"] = input.EffectiveDate;
    }
    if (input.EndpointStatus !== undefined) {
        bodyParams["EndpointStatus"] = input.EndpointStatus;
    }
    if (input.Location !== undefined) {
        bodyParams["Location"] = serializeAws_restJson1_1EndpointLocation(input.Location, context);
    }
    if (input.Metrics !== undefined) {
        bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(input.Metrics, context);
    }
    if (input.OptOut !== undefined) {
        bodyParams["OptOut"] = input.OptOut;
    }
    if (input.RequestId !== undefined) {
        bodyParams["RequestId"] = input.RequestId;
    }
    if (input.User !== undefined) {
        bodyParams["User"] = serializeAws_restJson1_1EndpointUser(input.User, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointSendConfiguration = (input, context) => {
    const bodyParams = {};
    if (input.BodyOverride !== undefined) {
        bodyParams["BodyOverride"] = input.BodyOverride;
    }
    if (input.Context !== undefined) {
        bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(input.Context, context);
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.TitleOverride !== undefined) {
        bodyParams["TitleOverride"] = input.TitleOverride;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EndpointUser = (input, context) => {
    const bodyParams = {};
    if (input.UserAttributes !== undefined) {
        bodyParams["UserAttributes"] = serializeAws_restJson1_1MapOfListOf__string(input.UserAttributes, context);
    }
    if (input.UserId !== undefined) {
        bodyParams["UserId"] = input.UserId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1Event = (input, context) => {
    const bodyParams = {};
    if (input.AppPackageName !== undefined) {
        bodyParams["AppPackageName"] = input.AppPackageName;
    }
    if (input.AppTitle !== undefined) {
        bodyParams["AppTitle"] = input.AppTitle;
    }
    if (input.AppVersionCode !== undefined) {
        bodyParams["AppVersionCode"] = input.AppVersionCode;
    }
    if (input.Attributes !== undefined) {
        bodyParams["Attributes"] = serializeAws_restJson1_1MapOf__string(input.Attributes, context);
    }
    if (input.ClientSdkVersion !== undefined) {
        bodyParams["ClientSdkVersion"] = input.ClientSdkVersion;
    }
    if (input.EventType !== undefined) {
        bodyParams["EventType"] = input.EventType;
    }
    if (input.Metrics !== undefined) {
        bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(input.Metrics, context);
    }
    if (input.SdkName !== undefined) {
        bodyParams["SdkName"] = input.SdkName;
    }
    if (input.Session !== undefined) {
        bodyParams["Session"] = serializeAws_restJson1_1Session(input.Session, context);
    }
    if (input.Timestamp !== undefined) {
        bodyParams["Timestamp"] = input.Timestamp;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EventCondition = (input, context) => {
    const bodyParams = {};
    if (input.Dimensions !== undefined) {
        bodyParams["Dimensions"] = serializeAws_restJson1_1EventDimensions(input.Dimensions, context);
    }
    if (input.MessageActivity !== undefined) {
        bodyParams["MessageActivity"] = input.MessageActivity;
    }
    return bodyParams;
};
const serializeAws_restJson1_1EventDimensions = (input, context) => {
    const bodyParams = {};
    if (input.Attributes !== undefined) {
        bodyParams["Attributes"] = serializeAws_restJson1_1MapOfAttributeDimension(input.Attributes, context);
    }
    if (input.EventType !== undefined) {
        bodyParams["EventType"] = serializeAws_restJson1_1SetDimension(input.EventType, context);
    }
    if (input.Metrics !== undefined) {
        bodyParams["Metrics"] = serializeAws_restJson1_1MapOfMetricDimension(input.Metrics, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EventsBatch = (input, context) => {
    const bodyParams = {};
    if (input.Endpoint !== undefined) {
        bodyParams["Endpoint"] = serializeAws_restJson1_1PublicEndpoint(input.Endpoint, context);
    }
    if (input.Events !== undefined) {
        bodyParams["Events"] = serializeAws_restJson1_1MapOfEvent(input.Events, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1EventsRequest = (input, context) => {
    const bodyParams = {};
    if (input.BatchItem !== undefined) {
        bodyParams["BatchItem"] = serializeAws_restJson1_1MapOfEventsBatch(input.BatchItem, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1ExportJobRequest = (input, context) => {
    const bodyParams = {};
    if (input.RoleArn !== undefined) {
        bodyParams["RoleArn"] = input.RoleArn;
    }
    if (input.S3UrlPrefix !== undefined) {
        bodyParams["S3UrlPrefix"] = input.S3UrlPrefix;
    }
    if (input.SegmentId !== undefined) {
        bodyParams["SegmentId"] = input.SegmentId;
    }
    if (input.SegmentVersion !== undefined) {
        bodyParams["SegmentVersion"] = input.SegmentVersion;
    }
    return bodyParams;
};
const serializeAws_restJson1_1GCMChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.ApiKey !== undefined) {
        bodyParams["ApiKey"] = input.ApiKey;
    }
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    return bodyParams;
};
const serializeAws_restJson1_1GCMMessage = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.CollapseKey !== undefined) {
        bodyParams["CollapseKey"] = input.CollapseKey;
    }
    if (input.Data !== undefined) {
        bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(input.Data, context);
    }
    if (input.IconReference !== undefined) {
        bodyParams["IconReference"] = input.IconReference;
    }
    if (input.ImageIconUrl !== undefined) {
        bodyParams["ImageIconUrl"] = input.ImageIconUrl;
    }
    if (input.ImageUrl !== undefined) {
        bodyParams["ImageUrl"] = input.ImageUrl;
    }
    if (input.Priority !== undefined) {
        bodyParams["Priority"] = input.Priority;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.RestrictedPackageName !== undefined) {
        bodyParams["RestrictedPackageName"] = input.RestrictedPackageName;
    }
    if (input.SilentPush !== undefined) {
        bodyParams["SilentPush"] = input.SilentPush;
    }
    if (input.SmallImageIconUrl !== undefined) {
        bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
    }
    if (input.Sound !== undefined) {
        bodyParams["Sound"] = input.Sound;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.TimeToLive !== undefined) {
        bodyParams["TimeToLive"] = input.TimeToLive;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1GPSCoordinates = (input, context) => {
    const bodyParams = {};
    if (input.Latitude !== undefined) {
        bodyParams["Latitude"] = input.Latitude;
    }
    if (input.Longitude !== undefined) {
        bodyParams["Longitude"] = input.Longitude;
    }
    return bodyParams;
};
const serializeAws_restJson1_1GPSPointDimension = (input, context) => {
    const bodyParams = {};
    if (input.Coordinates !== undefined) {
        bodyParams["Coordinates"] = serializeAws_restJson1_1GPSCoordinates(input.Coordinates, context);
    }
    if (input.RangeInKilometers !== undefined) {
        bodyParams["RangeInKilometers"] = input.RangeInKilometers;
    }
    return bodyParams;
};
const serializeAws_restJson1_1HoldoutActivity = (input, context) => {
    const bodyParams = {};
    if (input.NextActivity !== undefined) {
        bodyParams["NextActivity"] = input.NextActivity;
    }
    if (input.Percentage !== undefined) {
        bodyParams["Percentage"] = input.Percentage;
    }
    return bodyParams;
};
const serializeAws_restJson1_1ImportJobRequest = (input, context) => {
    const bodyParams = {};
    if (input.DefineSegment !== undefined) {
        bodyParams["DefineSegment"] = input.DefineSegment;
    }
    if (input.ExternalId !== undefined) {
        bodyParams["ExternalId"] = input.ExternalId;
    }
    if (input.Format !== undefined) {
        bodyParams["Format"] = input.Format;
    }
    if (input.RegisterEndpoints !== undefined) {
        bodyParams["RegisterEndpoints"] = input.RegisterEndpoints;
    }
    if (input.RoleArn !== undefined) {
        bodyParams["RoleArn"] = input.RoleArn;
    }
    if (input.S3Url !== undefined) {
        bodyParams["S3Url"] = input.S3Url;
    }
    if (input.SegmentId !== undefined) {
        bodyParams["SegmentId"] = input.SegmentId;
    }
    if (input.SegmentName !== undefined) {
        bodyParams["SegmentName"] = input.SegmentName;
    }
    return bodyParams;
};
const serializeAws_restJson1_1JourneyEmailMessage = (input, context) => {
    const bodyParams = {};
    if (input.FromAddress !== undefined) {
        bodyParams["FromAddress"] = input.FromAddress;
    }
    return bodyParams;
};
const serializeAws_restJson1_1JourneyLimits = (input, context) => {
    const bodyParams = {};
    if (input.DailyCap !== undefined) {
        bodyParams["DailyCap"] = input.DailyCap;
    }
    if (input.EndpointReentryCap !== undefined) {
        bodyParams["EndpointReentryCap"] = input.EndpointReentryCap;
    }
    if (input.MessagesPerSecond !== undefined) {
        bodyParams["MessagesPerSecond"] = input.MessagesPerSecond;
    }
    return bodyParams;
};
const serializeAws_restJson1_1JourneySchedule = (input, context) => {
    const bodyParams = {};
    if (input.EndTime !== undefined) {
        bodyParams["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.StartTime !== undefined) {
        bodyParams["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Timezone !== undefined) {
        bodyParams["Timezone"] = input.Timezone;
    }
    return bodyParams;
};
const serializeAws_restJson1_1JourneyStateRequest = (input, context) => {
    const bodyParams = {};
    if (input.State !== undefined) {
        bodyParams["State"] = input.State;
    }
    return bodyParams;
};
const serializeAws_restJson1_1ListOfEndpointBatchItem = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1EndpointBatchItem(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfMultiConditionalBranch = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1MultiConditionalBranch(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfRandomSplitEntry = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1RandomSplitEntry(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfSegmentDimensions = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1SegmentDimensions(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfSegmentGroup = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1SegmentGroup(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfSegmentReference = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1SegmentReference(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfSimpleCondition = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1SimpleCondition(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOfWriteTreatmentResource = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(serializeAws_restJson1_1WriteTreatmentResource(entry, context));
    }
    return contents;
};
const serializeAws_restJson1_1ListOf__string = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(entry);
    }
    return contents;
};
const serializeAws_restJson1_1MapOfActivity = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1Activity(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfAddressConfiguration = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1AddressConfiguration(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfAttributeDimension = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1AttributeDimension(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfEndpointSendConfiguration = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1EndpointSendConfiguration(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfEvent = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1Event(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfEventsBatch = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1EventsBatch(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfListOf__string = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1ListOf__string(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOfMetricDimension = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = serializeAws_restJson1_1MetricDimension(input[key], context);
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOf__double = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = input[key];
    });
    return mapParams;
};
const serializeAws_restJson1_1MapOf__string = (input, context) => {
    const mapParams = {};
    Object.keys(input).forEach(key => {
        mapParams[key] = input[key];
    });
    return mapParams;
};
const serializeAws_restJson1_1Message = (input, context) => {
    const bodyParams = {};
    if (input.Action !== undefined) {
        bodyParams["Action"] = input.Action;
    }
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.ImageIconUrl !== undefined) {
        bodyParams["ImageIconUrl"] = input.ImageIconUrl;
    }
    if (input.ImageSmallIconUrl !== undefined) {
        bodyParams["ImageSmallIconUrl"] = input.ImageSmallIconUrl;
    }
    if (input.ImageUrl !== undefined) {
        bodyParams["ImageUrl"] = input.ImageUrl;
    }
    if (input.JsonBody !== undefined) {
        bodyParams["JsonBody"] = input.JsonBody;
    }
    if (input.MediaUrl !== undefined) {
        bodyParams["MediaUrl"] = input.MediaUrl;
    }
    if (input.RawContent !== undefined) {
        bodyParams["RawContent"] = input.RawContent;
    }
    if (input.SilentPush !== undefined) {
        bodyParams["SilentPush"] = input.SilentPush;
    }
    if (input.TimeToLive !== undefined) {
        bodyParams["TimeToLive"] = input.TimeToLive;
    }
    if (input.Title !== undefined) {
        bodyParams["Title"] = input.Title;
    }
    if (input.Url !== undefined) {
        bodyParams["Url"] = input.Url;
    }
    return bodyParams;
};
const serializeAws_restJson1_1MessageConfiguration = (input, context) => {
    const bodyParams = {};
    if (input.ADMMessage !== undefined) {
        bodyParams["ADMMessage"] = serializeAws_restJson1_1Message(input.ADMMessage, context);
    }
    if (input.APNSMessage !== undefined) {
        bodyParams["APNSMessage"] = serializeAws_restJson1_1Message(input.APNSMessage, context);
    }
    if (input.BaiduMessage !== undefined) {
        bodyParams["BaiduMessage"] = serializeAws_restJson1_1Message(input.BaiduMessage, context);
    }
    if (input.DefaultMessage !== undefined) {
        bodyParams["DefaultMessage"] = serializeAws_restJson1_1Message(input.DefaultMessage, context);
    }
    if (input.EmailMessage !== undefined) {
        bodyParams["EmailMessage"] = serializeAws_restJson1_1CampaignEmailMessage(input.EmailMessage, context);
    }
    if (input.GCMMessage !== undefined) {
        bodyParams["GCMMessage"] = serializeAws_restJson1_1Message(input.GCMMessage, context);
    }
    if (input.SMSMessage !== undefined) {
        bodyParams["SMSMessage"] = serializeAws_restJson1_1CampaignSmsMessage(input.SMSMessage, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1MessageRequest = (input, context) => {
    const bodyParams = {};
    if (input.Addresses !== undefined) {
        bodyParams["Addresses"] = serializeAws_restJson1_1MapOfAddressConfiguration(input.Addresses, context);
    }
    if (input.Context !== undefined) {
        bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(input.Context, context);
    }
    if (input.Endpoints !== undefined) {
        bodyParams["Endpoints"] = serializeAws_restJson1_1MapOfEndpointSendConfiguration(input.Endpoints, context);
    }
    if (input.MessageConfiguration !== undefined) {
        bodyParams["MessageConfiguration"] = serializeAws_restJson1_1DirectMessageConfiguration(input.MessageConfiguration, context);
    }
    if (input.TemplateConfiguration !== undefined) {
        bodyParams["TemplateConfiguration"] = serializeAws_restJson1_1TemplateConfiguration(input.TemplateConfiguration, context);
    }
    if (input.TraceId !== undefined) {
        bodyParams["TraceId"] = input.TraceId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1MetricDimension = (input, context) => {
    const bodyParams = {};
    if (input.ComparisonOperator !== undefined) {
        bodyParams["ComparisonOperator"] = input.ComparisonOperator;
    }
    if (input.Value !== undefined) {
        bodyParams["Value"] = input.Value;
    }
    return bodyParams;
};
const serializeAws_restJson1_1MultiConditionalBranch = (input, context) => {
    const bodyParams = {};
    if (input.Condition !== undefined) {
        bodyParams["Condition"] = serializeAws_restJson1_1SimpleCondition(input.Condition, context);
    }
    if (input.NextActivity !== undefined) {
        bodyParams["NextActivity"] = input.NextActivity;
    }
    return bodyParams;
};
const serializeAws_restJson1_1MultiConditionalSplitActivity = (input, context) => {
    const bodyParams = {};
    if (input.Branches !== undefined) {
        bodyParams["Branches"] = serializeAws_restJson1_1ListOfMultiConditionalBranch(input.Branches, context);
    }
    if (input.DefaultActivity !== undefined) {
        bodyParams["DefaultActivity"] = input.DefaultActivity;
    }
    if (input.EvaluationWaitTime !== undefined) {
        bodyParams["EvaluationWaitTime"] = serializeAws_restJson1_1WaitTime(input.EvaluationWaitTime, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1NumberValidateRequest = (input, context) => {
    const bodyParams = {};
    if (input.IsoCountryCode !== undefined) {
        bodyParams["IsoCountryCode"] = input.IsoCountryCode;
    }
    if (input.PhoneNumber !== undefined) {
        bodyParams["PhoneNumber"] = input.PhoneNumber;
    }
    return bodyParams;
};
const serializeAws_restJson1_1PublicEndpoint = (input, context) => {
    const bodyParams = {};
    if (input.Address !== undefined) {
        bodyParams["Address"] = input.Address;
    }
    if (input.Attributes !== undefined) {
        bodyParams["Attributes"] = serializeAws_restJson1_1MapOfListOf__string(input.Attributes, context);
    }
    if (input.ChannelType !== undefined) {
        bodyParams["ChannelType"] = input.ChannelType;
    }
    if (input.Demographic !== undefined) {
        bodyParams["Demographic"] = serializeAws_restJson1_1EndpointDemographic(input.Demographic, context);
    }
    if (input.EffectiveDate !== undefined) {
        bodyParams["EffectiveDate"] = input.EffectiveDate;
    }
    if (input.EndpointStatus !== undefined) {
        bodyParams["EndpointStatus"] = input.EndpointStatus;
    }
    if (input.Location !== undefined) {
        bodyParams["Location"] = serializeAws_restJson1_1EndpointLocation(input.Location, context);
    }
    if (input.Metrics !== undefined) {
        bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(input.Metrics, context);
    }
    if (input.OptOut !== undefined) {
        bodyParams["OptOut"] = input.OptOut;
    }
    if (input.RequestId !== undefined) {
        bodyParams["RequestId"] = input.RequestId;
    }
    if (input.User !== undefined) {
        bodyParams["User"] = serializeAws_restJson1_1EndpointUser(input.User, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1PushNotificationTemplateRequest = (input, context) => {
    const bodyParams = {};
    if (input.ADM !== undefined) {
        bodyParams["ADM"] = serializeAws_restJson1_1AndroidPushNotificationTemplate(input.ADM, context);
    }
    if (input.APNS !== undefined) {
        bodyParams["APNS"] = serializeAws_restJson1_1APNSPushNotificationTemplate(input.APNS, context);
    }
    if (input.Baidu !== undefined) {
        bodyParams["Baidu"] = serializeAws_restJson1_1AndroidPushNotificationTemplate(input.Baidu, context);
    }
    if (input.Default !== undefined) {
        bodyParams["Default"] = serializeAws_restJson1_1DefaultPushNotificationTemplate(input.Default, context);
    }
    if (input.DefaultSubstitutions !== undefined) {
        bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
    }
    if (input.GCM !== undefined) {
        bodyParams["GCM"] = serializeAws_restJson1_1AndroidPushNotificationTemplate(input.GCM, context);
    }
    if (input.TemplateDescription !== undefined) {
        bodyParams["TemplateDescription"] = input.TemplateDescription;
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1QuietTime = (input, context) => {
    const bodyParams = {};
    if (input.End !== undefined) {
        bodyParams["End"] = input.End;
    }
    if (input.Start !== undefined) {
        bodyParams["Start"] = input.Start;
    }
    return bodyParams;
};
const serializeAws_restJson1_1RandomSplitActivity = (input, context) => {
    const bodyParams = {};
    if (input.Branches !== undefined) {
        bodyParams["Branches"] = serializeAws_restJson1_1ListOfRandomSplitEntry(input.Branches, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1RandomSplitEntry = (input, context) => {
    const bodyParams = {};
    if (input.NextActivity !== undefined) {
        bodyParams["NextActivity"] = input.NextActivity;
    }
    if (input.Percentage !== undefined) {
        bodyParams["Percentage"] = input.Percentage;
    }
    return bodyParams;
};
const serializeAws_restJson1_1RawEmail = (input, context) => {
    const bodyParams = {};
    if (input.Data !== undefined) {
        bodyParams["Data"] = context.base64Encoder(input.Data);
    }
    return bodyParams;
};
const serializeAws_restJson1_1RecencyDimension = (input, context) => {
    const bodyParams = {};
    if (input.Duration !== undefined) {
        bodyParams["Duration"] = input.Duration;
    }
    if (input.RecencyType !== undefined) {
        bodyParams["RecencyType"] = input.RecencyType;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SMSChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    if (input.SenderId !== undefined) {
        bodyParams["SenderId"] = input.SenderId;
    }
    if (input.ShortCode !== undefined) {
        bodyParams["ShortCode"] = input.ShortCode;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SMSMessage = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.Keyword !== undefined) {
        bodyParams["Keyword"] = input.Keyword;
    }
    if (input.MessageType !== undefined) {
        bodyParams["MessageType"] = input.MessageType;
    }
    if (input.OriginationNumber !== undefined) {
        bodyParams["OriginationNumber"] = input.OriginationNumber;
    }
    if (input.SenderId !== undefined) {
        bodyParams["SenderId"] = input.SenderId;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SMSTemplateRequest = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.DefaultSubstitutions !== undefined) {
        bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
    }
    if (input.TemplateDescription !== undefined) {
        bodyParams["TemplateDescription"] = input.TemplateDescription;
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1Schedule = (input, context) => {
    const bodyParams = {};
    if (input.EndTime !== undefined) {
        bodyParams["EndTime"] = input.EndTime;
    }
    if (input.EventFilter !== undefined) {
        bodyParams["EventFilter"] = serializeAws_restJson1_1CampaignEventFilter(input.EventFilter, context);
    }
    if (input.Frequency !== undefined) {
        bodyParams["Frequency"] = input.Frequency;
    }
    if (input.IsLocalTime !== undefined) {
        bodyParams["IsLocalTime"] = input.IsLocalTime;
    }
    if (input.QuietTime !== undefined) {
        bodyParams["QuietTime"] = serializeAws_restJson1_1QuietTime(input.QuietTime, context);
    }
    if (input.StartTime !== undefined) {
        bodyParams["StartTime"] = input.StartTime;
    }
    if (input.Timezone !== undefined) {
        bodyParams["Timezone"] = input.Timezone;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentBehaviors = (input, context) => {
    const bodyParams = {};
    if (input.Recency !== undefined) {
        bodyParams["Recency"] = serializeAws_restJson1_1RecencyDimension(input.Recency, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentCondition = (input, context) => {
    const bodyParams = {};
    if (input.SegmentId !== undefined) {
        bodyParams["SegmentId"] = input.SegmentId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentDemographics = (input, context) => {
    const bodyParams = {};
    if (input.AppVersion !== undefined) {
        bodyParams["AppVersion"] = serializeAws_restJson1_1SetDimension(input.AppVersion, context);
    }
    if (input.Channel !== undefined) {
        bodyParams["Channel"] = serializeAws_restJson1_1SetDimension(input.Channel, context);
    }
    if (input.DeviceType !== undefined) {
        bodyParams["DeviceType"] = serializeAws_restJson1_1SetDimension(input.DeviceType, context);
    }
    if (input.Make !== undefined) {
        bodyParams["Make"] = serializeAws_restJson1_1SetDimension(input.Make, context);
    }
    if (input.Model !== undefined) {
        bodyParams["Model"] = serializeAws_restJson1_1SetDimension(input.Model, context);
    }
    if (input.Platform !== undefined) {
        bodyParams["Platform"] = serializeAws_restJson1_1SetDimension(input.Platform, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentDimensions = (input, context) => {
    const bodyParams = {};
    if (input.Attributes !== undefined) {
        bodyParams["Attributes"] = serializeAws_restJson1_1MapOfAttributeDimension(input.Attributes, context);
    }
    if (input.Behavior !== undefined) {
        bodyParams["Behavior"] = serializeAws_restJson1_1SegmentBehaviors(input.Behavior, context);
    }
    if (input.Demographic !== undefined) {
        bodyParams["Demographic"] = serializeAws_restJson1_1SegmentDemographics(input.Demographic, context);
    }
    if (input.Location !== undefined) {
        bodyParams["Location"] = serializeAws_restJson1_1SegmentLocation(input.Location, context);
    }
    if (input.Metrics !== undefined) {
        bodyParams["Metrics"] = serializeAws_restJson1_1MapOfMetricDimension(input.Metrics, context);
    }
    if (input.UserAttributes !== undefined) {
        bodyParams["UserAttributes"] = serializeAws_restJson1_1MapOfAttributeDimension(input.UserAttributes, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentGroup = (input, context) => {
    const bodyParams = {};
    if (input.Dimensions !== undefined) {
        bodyParams["Dimensions"] = serializeAws_restJson1_1ListOfSegmentDimensions(input.Dimensions, context);
    }
    if (input.SourceSegments !== undefined) {
        bodyParams["SourceSegments"] = serializeAws_restJson1_1ListOfSegmentReference(input.SourceSegments, context);
    }
    if (input.SourceType !== undefined) {
        bodyParams["SourceType"] = input.SourceType;
    }
    if (input.Type !== undefined) {
        bodyParams["Type"] = input.Type;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentGroupList = (input, context) => {
    const bodyParams = {};
    if (input.Groups !== undefined) {
        bodyParams["Groups"] = serializeAws_restJson1_1ListOfSegmentGroup(input.Groups, context);
    }
    if (input.Include !== undefined) {
        bodyParams["Include"] = input.Include;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentLocation = (input, context) => {
    const bodyParams = {};
    if (input.Country !== undefined) {
        bodyParams["Country"] = serializeAws_restJson1_1SetDimension(input.Country, context);
    }
    if (input.GPSPoint !== undefined) {
        bodyParams["GPSPoint"] = serializeAws_restJson1_1GPSPointDimension(input.GPSPoint, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SegmentReference = (input, context) => {
    const bodyParams = {};
    if (input.Id !== undefined) {
        bodyParams["Id"] = input.Id;
    }
    if (input.Version !== undefined) {
        bodyParams["Version"] = input.Version;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SendUsersMessageRequest = (input, context) => {
    const bodyParams = {};
    if (input.Context !== undefined) {
        bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(input.Context, context);
    }
    if (input.MessageConfiguration !== undefined) {
        bodyParams["MessageConfiguration"] = serializeAws_restJson1_1DirectMessageConfiguration(input.MessageConfiguration, context);
    }
    if (input.TemplateConfiguration !== undefined) {
        bodyParams["TemplateConfiguration"] = serializeAws_restJson1_1TemplateConfiguration(input.TemplateConfiguration, context);
    }
    if (input.TraceId !== undefined) {
        bodyParams["TraceId"] = input.TraceId;
    }
    if (input.Users !== undefined) {
        bodyParams["Users"] = serializeAws_restJson1_1MapOfEndpointSendConfiguration(input.Users, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1Session = (input, context) => {
    const bodyParams = {};
    if (input.Duration !== undefined) {
        bodyParams["Duration"] = input.Duration;
    }
    if (input.Id !== undefined) {
        bodyParams["Id"] = input.Id;
    }
    if (input.StartTimestamp !== undefined) {
        bodyParams["StartTimestamp"] = input.StartTimestamp;
    }
    if (input.StopTimestamp !== undefined) {
        bodyParams["StopTimestamp"] = input.StopTimestamp;
    }
    return bodyParams;
};
const serializeAws_restJson1_1SetDimension = (input, context) => {
    const bodyParams = {};
    if (input.DimensionType !== undefined) {
        bodyParams["DimensionType"] = input.DimensionType;
    }
    if (input.Values !== undefined) {
        bodyParams["Values"] = serializeAws_restJson1_1ListOf__string(input.Values, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SimpleCondition = (input, context) => {
    const bodyParams = {};
    if (input.EventCondition !== undefined) {
        bodyParams["EventCondition"] = serializeAws_restJson1_1EventCondition(input.EventCondition, context);
    }
    if (input.SegmentCondition !== undefined) {
        bodyParams["SegmentCondition"] = serializeAws_restJson1_1SegmentCondition(input.SegmentCondition, context);
    }
    if (input.SegmentDimensions !== undefined) {
        bodyParams["segmentDimensions"] = serializeAws_restJson1_1SegmentDimensions(input.SegmentDimensions, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SimpleEmail = (input, context) => {
    const bodyParams = {};
    if (input.HtmlPart !== undefined) {
        bodyParams["HtmlPart"] = serializeAws_restJson1_1SimpleEmailPart(input.HtmlPart, context);
    }
    if (input.Subject !== undefined) {
        bodyParams["Subject"] = serializeAws_restJson1_1SimpleEmailPart(input.Subject, context);
    }
    if (input.TextPart !== undefined) {
        bodyParams["TextPart"] = serializeAws_restJson1_1SimpleEmailPart(input.TextPart, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1SimpleEmailPart = (input, context) => {
    const bodyParams = {};
    if (input.Charset !== undefined) {
        bodyParams["Charset"] = input.Charset;
    }
    if (input.Data !== undefined) {
        bodyParams["Data"] = input.Data;
    }
    return bodyParams;
};
const serializeAws_restJson1_1StartCondition = (input, context) => {
    const bodyParams = {};
    if (input.Description !== undefined) {
        bodyParams["Description"] = input.Description;
    }
    if (input.SegmentStartCondition !== undefined) {
        bodyParams["SegmentStartCondition"] = serializeAws_restJson1_1SegmentCondition(input.SegmentStartCondition, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1TagsModel = (input, context) => {
    const bodyParams = {};
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1Template = (input, context) => {
    const bodyParams = {};
    if (input.Name !== undefined) {
        bodyParams["Name"] = input.Name;
    }
    if (input.Version !== undefined) {
        bodyParams["Version"] = input.Version;
    }
    return bodyParams;
};
const serializeAws_restJson1_1TemplateActiveVersionRequest = (input, context) => {
    const bodyParams = {};
    if (input.Version !== undefined) {
        bodyParams["Version"] = input.Version;
    }
    return bodyParams;
};
const serializeAws_restJson1_1TemplateConfiguration = (input, context) => {
    const bodyParams = {};
    if (input.EmailTemplate !== undefined) {
        bodyParams["EmailTemplate"] = serializeAws_restJson1_1Template(input.EmailTemplate, context);
    }
    if (input.PushTemplate !== undefined) {
        bodyParams["PushTemplate"] = serializeAws_restJson1_1Template(input.PushTemplate, context);
    }
    if (input.SMSTemplate !== undefined) {
        bodyParams["SMSTemplate"] = serializeAws_restJson1_1Template(input.SMSTemplate, context);
    }
    if (input.VoiceTemplate !== undefined) {
        bodyParams["VoiceTemplate"] = serializeAws_restJson1_1Template(input.VoiceTemplate, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1UpdateAttributesRequest = (input, context) => {
    const bodyParams = {};
    if (input.Blacklist !== undefined) {
        bodyParams["Blacklist"] = serializeAws_restJson1_1ListOf__string(input.Blacklist, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1VoiceChannelRequest = (input, context) => {
    const bodyParams = {};
    if (input.Enabled !== undefined) {
        bodyParams["Enabled"] = input.Enabled;
    }
    return bodyParams;
};
const serializeAws_restJson1_1VoiceMessage = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.LanguageCode !== undefined) {
        bodyParams["LanguageCode"] = input.LanguageCode;
    }
    if (input.OriginationNumber !== undefined) {
        bodyParams["OriginationNumber"] = input.OriginationNumber;
    }
    if (input.Substitutions !== undefined) {
        bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(input.Substitutions, context);
    }
    if (input.VoiceId !== undefined) {
        bodyParams["VoiceId"] = input.VoiceId;
    }
    return bodyParams;
};
const serializeAws_restJson1_1VoiceTemplateRequest = (input, context) => {
    const bodyParams = {};
    if (input.Body !== undefined) {
        bodyParams["Body"] = input.Body;
    }
    if (input.DefaultSubstitutions !== undefined) {
        bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
    }
    if (input.LanguageCode !== undefined) {
        bodyParams["LanguageCode"] = input.LanguageCode;
    }
    if (input.TemplateDescription !== undefined) {
        bodyParams["TemplateDescription"] = input.TemplateDescription;
    }
    if (input.VoiceId !== undefined) {
        bodyParams["VoiceId"] = input.VoiceId;
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1WaitActivity = (input, context) => {
    const bodyParams = {};
    if (input.NextActivity !== undefined) {
        bodyParams["NextActivity"] = input.NextActivity;
    }
    if (input.WaitTime !== undefined) {
        bodyParams["WaitTime"] = serializeAws_restJson1_1WaitTime(input.WaitTime, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1WaitTime = (input, context) => {
    const bodyParams = {};
    if (input.WaitFor !== undefined) {
        bodyParams["WaitFor"] = input.WaitFor;
    }
    if (input.WaitUntil !== undefined) {
        bodyParams["WaitUntil"] = input.WaitUntil;
    }
    return bodyParams;
};
const serializeAws_restJson1_1WriteApplicationSettingsRequest = (input, context) => {
    const bodyParams = {};
    if (input.CampaignHook !== undefined) {
        bodyParams["CampaignHook"] = serializeAws_restJson1_1CampaignHook(input.CampaignHook, context);
    }
    if (input.CloudWatchMetricsEnabled !== undefined) {
        bodyParams["CloudWatchMetricsEnabled"] = input.CloudWatchMetricsEnabled;
    }
    if (input.Limits !== undefined) {
        bodyParams["Limits"] = serializeAws_restJson1_1CampaignLimits(input.Limits, context);
    }
    if (input.QuietTime !== undefined) {
        bodyParams["QuietTime"] = serializeAws_restJson1_1QuietTime(input.QuietTime, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1WriteCampaignRequest = (input, context) => {
    const bodyParams = {};
    if (input.AdditionalTreatments !== undefined) {
        bodyParams["AdditionalTreatments"] = serializeAws_restJson1_1ListOfWriteTreatmentResource(input.AdditionalTreatments, context);
    }
    if (input.Description !== undefined) {
        bodyParams["Description"] = input.Description;
    }
    if (input.HoldoutPercent !== undefined) {
        bodyParams["HoldoutPercent"] = input.HoldoutPercent;
    }
    if (input.Hook !== undefined) {
        bodyParams["Hook"] = serializeAws_restJson1_1CampaignHook(input.Hook, context);
    }
    if (input.IsPaused !== undefined) {
        bodyParams["IsPaused"] = input.IsPaused;
    }
    if (input.Limits !== undefined) {
        bodyParams["Limits"] = serializeAws_restJson1_1CampaignLimits(input.Limits, context);
    }
    if (input.MessageConfiguration !== undefined) {
        bodyParams["MessageConfiguration"] = serializeAws_restJson1_1MessageConfiguration(input.MessageConfiguration, context);
    }
    if (input.Name !== undefined) {
        bodyParams["Name"] = input.Name;
    }
    if (input.Schedule !== undefined) {
        bodyParams["Schedule"] = serializeAws_restJson1_1Schedule(input.Schedule, context);
    }
    if (input.SegmentId !== undefined) {
        bodyParams["SegmentId"] = input.SegmentId;
    }
    if (input.SegmentVersion !== undefined) {
        bodyParams["SegmentVersion"] = input.SegmentVersion;
    }
    if (input.TemplateConfiguration !== undefined) {
        bodyParams["TemplateConfiguration"] = serializeAws_restJson1_1TemplateConfiguration(input.TemplateConfiguration, context);
    }
    if (input.TreatmentDescription !== undefined) {
        bodyParams["TreatmentDescription"] = input.TreatmentDescription;
    }
    if (input.TreatmentName !== undefined) {
        bodyParams["TreatmentName"] = input.TreatmentName;
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1WriteEventStream = (input, context) => {
    const bodyParams = {};
    if (input.DestinationStreamArn !== undefined) {
        bodyParams["DestinationStreamArn"] = input.DestinationStreamArn;
    }
    if (input.RoleArn !== undefined) {
        bodyParams["RoleArn"] = input.RoleArn;
    }
    return bodyParams;
};
const serializeAws_restJson1_1WriteJourneyRequest = (input, context) => {
    const bodyParams = {};
    if (input.Activities !== undefined) {
        bodyParams["Activities"] = serializeAws_restJson1_1MapOfActivity(input.Activities, context);
    }
    if (input.CreationDate !== undefined) {
        bodyParams["CreationDate"] = input.CreationDate;
    }
    if (input.LastModifiedDate !== undefined) {
        bodyParams["LastModifiedDate"] = input.LastModifiedDate;
    }
    if (input.Limits !== undefined) {
        bodyParams["Limits"] = serializeAws_restJson1_1JourneyLimits(input.Limits, context);
    }
    if (input.LocalTime !== undefined) {
        bodyParams["LocalTime"] = input.LocalTime;
    }
    if (input.Name !== undefined) {
        bodyParams["Name"] = input.Name;
    }
    if (input.QuietTime !== undefined) {
        bodyParams["QuietTime"] = serializeAws_restJson1_1QuietTime(input.QuietTime, context);
    }
    if (input.RefreshFrequency !== undefined) {
        bodyParams["RefreshFrequency"] = input.RefreshFrequency;
    }
    if (input.Schedule !== undefined) {
        bodyParams["Schedule"] = serializeAws_restJson1_1JourneySchedule(input.Schedule, context);
    }
    if (input.StartActivity !== undefined) {
        bodyParams["StartActivity"] = input.StartActivity;
    }
    if (input.StartCondition !== undefined) {
        bodyParams["StartCondition"] = serializeAws_restJson1_1StartCondition(input.StartCondition, context);
    }
    if (input.State !== undefined) {
        bodyParams["State"] = input.State;
    }
    return bodyParams;
};
const serializeAws_restJson1_1WriteSegmentRequest = (input, context) => {
    const bodyParams = {};
    if (input.Dimensions !== undefined) {
        bodyParams["Dimensions"] = serializeAws_restJson1_1SegmentDimensions(input.Dimensions, context);
    }
    if (input.Name !== undefined) {
        bodyParams["Name"] = input.Name;
    }
    if (input.SegmentGroups !== undefined) {
        bodyParams["SegmentGroups"] = serializeAws_restJson1_1SegmentGroupList(input.SegmentGroups, context);
    }
    if (input.tags !== undefined) {
        bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(input.tags, context);
    }
    return bodyParams;
};
const serializeAws_restJson1_1WriteTreatmentResource = (input, context) => {
    const bodyParams = {};
    if (input.MessageConfiguration !== undefined) {
        bodyParams["MessageConfiguration"] = serializeAws_restJson1_1MessageConfiguration(input.MessageConfiguration, context);
    }
    if (input.Schedule !== undefined) {
        bodyParams["Schedule"] = serializeAws_restJson1_1Schedule(input.Schedule, context);
    }
    if (input.SizePercent !== undefined) {
        bodyParams["SizePercent"] = input.SizePercent;
    }
    if (input.TemplateConfiguration !== undefined) {
        bodyParams["TemplateConfiguration"] = serializeAws_restJson1_1TemplateConfiguration(input.TemplateConfiguration, context);
    }
    if (input.TreatmentDescription !== undefined) {
        bodyParams["TreatmentDescription"] = input.TreatmentDescription;
    }
    if (input.TreatmentName !== undefined) {
        bodyParams["TreatmentName"] = input.TreatmentName;
    }
    return bodyParams;
};
const deserializeAws_restJson1_1ADMChannelResponse = (output, context) => {
    let contents = {
        __type: "ADMChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1APNSChannelResponse = (output, context) => {
    let contents = {
        __type: "APNSChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        DefaultAuthenticationMethod: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        HasTokenKey: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultAuthenticationMethod !== undefined &&
        output.DefaultAuthenticationMethod !== null) {
        contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
        contents.HasTokenKey = output.HasTokenKey;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1APNSPushNotificationTemplate = (output, context) => {
    let contents = {
        __type: "APNSPushNotificationTemplate",
        Action: undefined,
        Body: undefined,
        MediaUrl: undefined,
        RawContent: undefined,
        Sound: undefined,
        Title: undefined,
        Url: undefined
    };
    if (output.Action !== undefined && output.Action !== null) {
        contents.Action = output.Action;
    }
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.MediaUrl !== undefined && output.MediaUrl !== null) {
        contents.MediaUrl = output.MediaUrl;
    }
    if (output.RawContent !== undefined && output.RawContent !== null) {
        contents.RawContent = output.RawContent;
    }
    if (output.Sound !== undefined && output.Sound !== null) {
        contents.Sound = output.Sound;
    }
    if (output.Title !== undefined && output.Title !== null) {
        contents.Title = output.Title;
    }
    if (output.Url !== undefined && output.Url !== null) {
        contents.Url = output.Url;
    }
    return contents;
};
const deserializeAws_restJson1_1APNSSandboxChannelResponse = (output, context) => {
    let contents = {
        __type: "APNSSandboxChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        DefaultAuthenticationMethod: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        HasTokenKey: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultAuthenticationMethod !== undefined &&
        output.DefaultAuthenticationMethod !== null) {
        contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
        contents.HasTokenKey = output.HasTokenKey;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1APNSVoipChannelResponse = (output, context) => {
    let contents = {
        __type: "APNSVoipChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        DefaultAuthenticationMethod: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        HasTokenKey: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultAuthenticationMethod !== undefined &&
        output.DefaultAuthenticationMethod !== null) {
        contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
        contents.HasTokenKey = output.HasTokenKey;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1APNSVoipSandboxChannelResponse = (output, context) => {
    let contents = {
        __type: "APNSVoipSandboxChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        DefaultAuthenticationMethod: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        HasTokenKey: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultAuthenticationMethod !== undefined &&
        output.DefaultAuthenticationMethod !== null) {
        contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
        contents.HasTokenKey = output.HasTokenKey;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1ActivitiesResponse = (output, context) => {
    let contents = {
        __type: "ActivitiesResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfActivityResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1Activity = (output, context) => {
    let contents = {
        __type: "Activity",
        ConditionalSplit: undefined,
        Description: undefined,
        EMAIL: undefined,
        Holdout: undefined,
        MultiCondition: undefined,
        RandomSplit: undefined,
        Wait: undefined
    };
    if (output.ConditionalSplit !== undefined &&
        output.ConditionalSplit !== null) {
        contents.ConditionalSplit = deserializeAws_restJson1_1ConditionalSplitActivity(output.ConditionalSplit, context);
    }
    if (output.Description !== undefined && output.Description !== null) {
        contents.Description = output.Description;
    }
    if (output.EMAIL !== undefined && output.EMAIL !== null) {
        contents.EMAIL = deserializeAws_restJson1_1EmailMessageActivity(output.EMAIL, context);
    }
    if (output.Holdout !== undefined && output.Holdout !== null) {
        contents.Holdout = deserializeAws_restJson1_1HoldoutActivity(output.Holdout, context);
    }
    if (output.MultiCondition !== undefined && output.MultiCondition !== null) {
        contents.MultiCondition = deserializeAws_restJson1_1MultiConditionalSplitActivity(output.MultiCondition, context);
    }
    if (output.RandomSplit !== undefined && output.RandomSplit !== null) {
        contents.RandomSplit = deserializeAws_restJson1_1RandomSplitActivity(output.RandomSplit, context);
    }
    if (output.Wait !== undefined && output.Wait !== null) {
        contents.Wait = deserializeAws_restJson1_1WaitActivity(output.Wait, context);
    }
    return contents;
};
const deserializeAws_restJson1_1ActivityResponse = (output, context) => {
    let contents = {
        __type: "ActivityResponse",
        ApplicationId: undefined,
        CampaignId: undefined,
        End: undefined,
        Id: undefined,
        Result: undefined,
        ScheduledStart: undefined,
        Start: undefined,
        State: undefined,
        SuccessfulEndpointCount: undefined,
        TimezonesCompletedCount: undefined,
        TimezonesTotalCount: undefined,
        TotalEndpointCount: undefined,
        TreatmentId: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CampaignId !== undefined && output.CampaignId !== null) {
        contents.CampaignId = output.CampaignId;
    }
    if (output.End !== undefined && output.End !== null) {
        contents.End = output.End;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.Result !== undefined && output.Result !== null) {
        contents.Result = output.Result;
    }
    if (output.ScheduledStart !== undefined && output.ScheduledStart !== null) {
        contents.ScheduledStart = output.ScheduledStart;
    }
    if (output.Start !== undefined && output.Start !== null) {
        contents.Start = output.Start;
    }
    if (output.State !== undefined && output.State !== null) {
        contents.State = output.State;
    }
    if (output.SuccessfulEndpointCount !== undefined &&
        output.SuccessfulEndpointCount !== null) {
        contents.SuccessfulEndpointCount = output.SuccessfulEndpointCount;
    }
    if (output.TimezonesCompletedCount !== undefined &&
        output.TimezonesCompletedCount !== null) {
        contents.TimezonesCompletedCount = output.TimezonesCompletedCount;
    }
    if (output.TimezonesTotalCount !== undefined &&
        output.TimezonesTotalCount !== null) {
        contents.TimezonesTotalCount = output.TimezonesTotalCount;
    }
    if (output.TotalEndpointCount !== undefined &&
        output.TotalEndpointCount !== null) {
        contents.TotalEndpointCount = output.TotalEndpointCount;
    }
    if (output.TreatmentId !== undefined && output.TreatmentId !== null) {
        contents.TreatmentId = output.TreatmentId;
    }
    return contents;
};
const deserializeAws_restJson1_1AndroidPushNotificationTemplate = (output, context) => {
    let contents = {
        __type: "AndroidPushNotificationTemplate",
        Action: undefined,
        Body: undefined,
        ImageIconUrl: undefined,
        ImageUrl: undefined,
        RawContent: undefined,
        SmallImageIconUrl: undefined,
        Sound: undefined,
        Title: undefined,
        Url: undefined
    };
    if (output.Action !== undefined && output.Action !== null) {
        contents.Action = output.Action;
    }
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.ImageIconUrl !== undefined && output.ImageIconUrl !== null) {
        contents.ImageIconUrl = output.ImageIconUrl;
    }
    if (output.ImageUrl !== undefined && output.ImageUrl !== null) {
        contents.ImageUrl = output.ImageUrl;
    }
    if (output.RawContent !== undefined && output.RawContent !== null) {
        contents.RawContent = output.RawContent;
    }
    if (output.SmallImageIconUrl !== undefined &&
        output.SmallImageIconUrl !== null) {
        contents.SmallImageIconUrl = output.SmallImageIconUrl;
    }
    if (output.Sound !== undefined && output.Sound !== null) {
        contents.Sound = output.Sound;
    }
    if (output.Title !== undefined && output.Title !== null) {
        contents.Title = output.Title;
    }
    if (output.Url !== undefined && output.Url !== null) {
        contents.Url = output.Url;
    }
    return contents;
};
const deserializeAws_restJson1_1ApplicationDateRangeKpiResponse = (output, context) => {
    let contents = {
        __type: "ApplicationDateRangeKpiResponse",
        ApplicationId: undefined,
        EndTime: undefined,
        KpiName: undefined,
        KpiResult: undefined,
        NextToken: undefined,
        StartTime: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.EndTime !== undefined && output.EndTime !== null) {
        contents.EndTime = new Date(output.EndTime);
    }
    if (output.KpiName !== undefined && output.KpiName !== null) {
        contents.KpiName = output.KpiName;
    }
    if (output.KpiResult !== undefined && output.KpiResult !== null) {
        contents.KpiResult = deserializeAws_restJson1_1BaseKpiResult(output.KpiResult, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    if (output.StartTime !== undefined && output.StartTime !== null) {
        contents.StartTime = new Date(output.StartTime);
    }
    return contents;
};
const deserializeAws_restJson1_1ApplicationResponse = (output, context) => {
    let contents = {
        __type: "ApplicationResponse",
        Arn: undefined,
        Id: undefined,
        Name: undefined,
        tags: undefined
    };
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1ApplicationSettingsResource = (output, context) => {
    let contents = {
        __type: "ApplicationSettingsResource",
        ApplicationId: undefined,
        CampaignHook: undefined,
        LastModifiedDate: undefined,
        Limits: undefined,
        QuietTime: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CampaignHook !== undefined && output.CampaignHook !== null) {
        contents.CampaignHook = deserializeAws_restJson1_1CampaignHook(output.CampaignHook, context);
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Limits !== undefined && output.Limits !== null) {
        contents.Limits = deserializeAws_restJson1_1CampaignLimits(output.Limits, context);
    }
    if (output.QuietTime !== undefined && output.QuietTime !== null) {
        contents.QuietTime = deserializeAws_restJson1_1QuietTime(output.QuietTime, context);
    }
    return contents;
};
const deserializeAws_restJson1_1ApplicationsResponse = (output, context) => {
    let contents = {
        __type: "ApplicationsResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfApplicationResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1AttributeDimension = (output, context) => {
    let contents = {
        __type: "AttributeDimension",
        AttributeType: undefined,
        Values: undefined
    };
    if (output.AttributeType !== undefined && output.AttributeType !== null) {
        contents.AttributeType = output.AttributeType;
    }
    if (output.Values !== undefined && output.Values !== null) {
        contents.Values = deserializeAws_restJson1_1ListOf__string(output.Values, context);
    }
    return contents;
};
const deserializeAws_restJson1_1AttributesResource = (output, context) => {
    let contents = {
        __type: "AttributesResource",
        ApplicationId: undefined,
        AttributeType: undefined,
        Attributes: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.AttributeType !== undefined && output.AttributeType !== null) {
        contents.AttributeType = output.AttributeType;
    }
    if (output.Attributes !== undefined && output.Attributes !== null) {
        contents.Attributes = deserializeAws_restJson1_1ListOf__string(output.Attributes, context);
    }
    return contents;
};
const deserializeAws_restJson1_1BaiduChannelResponse = (output, context) => {
    let contents = {
        __type: "BaiduChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        Credential: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Credential !== undefined && output.Credential !== null) {
        contents.Credential = output.Credential;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1BaseKpiResult = (output, context) => {
    let contents = {
        __type: "BaseKpiResult",
        Rows: undefined
    };
    if (output.Rows !== undefined && output.Rows !== null) {
        contents.Rows = deserializeAws_restJson1_1ListOfResultRow(output.Rows, context);
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignDateRangeKpiResponse = (output, context) => {
    let contents = {
        __type: "CampaignDateRangeKpiResponse",
        ApplicationId: undefined,
        CampaignId: undefined,
        EndTime: undefined,
        KpiName: undefined,
        KpiResult: undefined,
        NextToken: undefined,
        StartTime: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CampaignId !== undefined && output.CampaignId !== null) {
        contents.CampaignId = output.CampaignId;
    }
    if (output.EndTime !== undefined && output.EndTime !== null) {
        contents.EndTime = new Date(output.EndTime);
    }
    if (output.KpiName !== undefined && output.KpiName !== null) {
        contents.KpiName = output.KpiName;
    }
    if (output.KpiResult !== undefined && output.KpiResult !== null) {
        contents.KpiResult = deserializeAws_restJson1_1BaseKpiResult(output.KpiResult, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    if (output.StartTime !== undefined && output.StartTime !== null) {
        contents.StartTime = new Date(output.StartTime);
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignEmailMessage = (output, context) => {
    let contents = {
        __type: "CampaignEmailMessage",
        Body: undefined,
        FromAddress: undefined,
        HtmlBody: undefined,
        Title: undefined
    };
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.FromAddress !== undefined && output.FromAddress !== null) {
        contents.FromAddress = output.FromAddress;
    }
    if (output.HtmlBody !== undefined && output.HtmlBody !== null) {
        contents.HtmlBody = output.HtmlBody;
    }
    if (output.Title !== undefined && output.Title !== null) {
        contents.Title = output.Title;
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignEventFilter = (output, context) => {
    let contents = {
        __type: "CampaignEventFilter",
        Dimensions: undefined,
        FilterType: undefined
    };
    if (output.Dimensions !== undefined && output.Dimensions !== null) {
        contents.Dimensions = deserializeAws_restJson1_1EventDimensions(output.Dimensions, context);
    }
    if (output.FilterType !== undefined && output.FilterType !== null) {
        contents.FilterType = output.FilterType;
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignHook = (output, context) => {
    let contents = {
        __type: "CampaignHook",
        LambdaFunctionName: undefined,
        Mode: undefined,
        WebUrl: undefined
    };
    if (output.LambdaFunctionName !== undefined &&
        output.LambdaFunctionName !== null) {
        contents.LambdaFunctionName = output.LambdaFunctionName;
    }
    if (output.Mode !== undefined && output.Mode !== null) {
        contents.Mode = output.Mode;
    }
    if (output.WebUrl !== undefined && output.WebUrl !== null) {
        contents.WebUrl = output.WebUrl;
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignLimits = (output, context) => {
    let contents = {
        __type: "CampaignLimits",
        Daily: undefined,
        MaximumDuration: undefined,
        MessagesPerSecond: undefined,
        Total: undefined
    };
    if (output.Daily !== undefined && output.Daily !== null) {
        contents.Daily = output.Daily;
    }
    if (output.MaximumDuration !== undefined && output.MaximumDuration !== null) {
        contents.MaximumDuration = output.MaximumDuration;
    }
    if (output.MessagesPerSecond !== undefined &&
        output.MessagesPerSecond !== null) {
        contents.MessagesPerSecond = output.MessagesPerSecond;
    }
    if (output.Total !== undefined && output.Total !== null) {
        contents.Total = output.Total;
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignResponse = (output, context) => {
    let contents = {
        __type: "CampaignResponse",
        AdditionalTreatments: undefined,
        ApplicationId: undefined,
        Arn: undefined,
        CreationDate: undefined,
        DefaultState: undefined,
        Description: undefined,
        HoldoutPercent: undefined,
        Hook: undefined,
        Id: undefined,
        IsPaused: undefined,
        LastModifiedDate: undefined,
        Limits: undefined,
        MessageConfiguration: undefined,
        Name: undefined,
        Schedule: undefined,
        SegmentId: undefined,
        SegmentVersion: undefined,
        State: undefined,
        TemplateConfiguration: undefined,
        TreatmentDescription: undefined,
        TreatmentName: undefined,
        Version: undefined,
        tags: undefined
    };
    if (output.AdditionalTreatments !== undefined &&
        output.AdditionalTreatments !== null) {
        contents.AdditionalTreatments = deserializeAws_restJson1_1ListOfTreatmentResource(output.AdditionalTreatments, context);
    }
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultState !== undefined && output.DefaultState !== null) {
        contents.DefaultState = deserializeAws_restJson1_1CampaignState(output.DefaultState, context);
    }
    if (output.Description !== undefined && output.Description !== null) {
        contents.Description = output.Description;
    }
    if (output.HoldoutPercent !== undefined && output.HoldoutPercent !== null) {
        contents.HoldoutPercent = output.HoldoutPercent;
    }
    if (output.Hook !== undefined && output.Hook !== null) {
        contents.Hook = deserializeAws_restJson1_1CampaignHook(output.Hook, context);
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsPaused !== undefined && output.IsPaused !== null) {
        contents.IsPaused = output.IsPaused;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Limits !== undefined && output.Limits !== null) {
        contents.Limits = deserializeAws_restJson1_1CampaignLimits(output.Limits, context);
    }
    if (output.MessageConfiguration !== undefined &&
        output.MessageConfiguration !== null) {
        contents.MessageConfiguration = deserializeAws_restJson1_1MessageConfiguration(output.MessageConfiguration, context);
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    if (output.Schedule !== undefined && output.Schedule !== null) {
        contents.Schedule = deserializeAws_restJson1_1Schedule(output.Schedule, context);
    }
    if (output.SegmentId !== undefined && output.SegmentId !== null) {
        contents.SegmentId = output.SegmentId;
    }
    if (output.SegmentVersion !== undefined && output.SegmentVersion !== null) {
        contents.SegmentVersion = output.SegmentVersion;
    }
    if (output.State !== undefined && output.State !== null) {
        contents.State = deserializeAws_restJson1_1CampaignState(output.State, context);
    }
    if (output.TemplateConfiguration !== undefined &&
        output.TemplateConfiguration !== null) {
        contents.TemplateConfiguration = deserializeAws_restJson1_1TemplateConfiguration(output.TemplateConfiguration, context);
    }
    if (output.TreatmentDescription !== undefined &&
        output.TreatmentDescription !== null) {
        contents.TreatmentDescription = output.TreatmentDescription;
    }
    if (output.TreatmentName !== undefined && output.TreatmentName !== null) {
        contents.TreatmentName = output.TreatmentName;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignSmsMessage = (output, context) => {
    let contents = {
        __type: "CampaignSmsMessage",
        Body: undefined,
        MessageType: undefined,
        SenderId: undefined
    };
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.MessageType !== undefined && output.MessageType !== null) {
        contents.MessageType = output.MessageType;
    }
    if (output.SenderId !== undefined && output.SenderId !== null) {
        contents.SenderId = output.SenderId;
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignState = (output, context) => {
    let contents = {
        __type: "CampaignState",
        CampaignStatus: undefined
    };
    if (output.CampaignStatus !== undefined && output.CampaignStatus !== null) {
        contents.CampaignStatus = output.CampaignStatus;
    }
    return contents;
};
const deserializeAws_restJson1_1CampaignsResponse = (output, context) => {
    let contents = {
        __type: "CampaignsResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfCampaignResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1ChannelResponse = (output, context) => {
    let contents = {
        __type: "ChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1ChannelsResponse = (output, context) => {
    let contents = {
        __type: "ChannelsResponse",
        Channels: undefined
    };
    if (output.Channels !== undefined && output.Channels !== null) {
        contents.Channels = deserializeAws_restJson1_1MapOfChannelResponse(output.Channels, context);
    }
    return contents;
};
const deserializeAws_restJson1_1Condition = (output, context) => {
    let contents = {
        __type: "Condition",
        Conditions: undefined,
        Operator: undefined
    };
    if (output.Conditions !== undefined && output.Conditions !== null) {
        contents.Conditions = deserializeAws_restJson1_1ListOfSimpleCondition(output.Conditions, context);
    }
    if (output.Operator !== undefined && output.Operator !== null) {
        contents.Operator = output.Operator;
    }
    return contents;
};
const deserializeAws_restJson1_1ConditionalSplitActivity = (output, context) => {
    let contents = {
        __type: "ConditionalSplitActivity",
        Condition: undefined,
        EvaluationWaitTime: undefined,
        FalseActivity: undefined,
        TrueActivity: undefined
    };
    if (output.Condition !== undefined && output.Condition !== null) {
        contents.Condition = deserializeAws_restJson1_1Condition(output.Condition, context);
    }
    if (output.EvaluationWaitTime !== undefined &&
        output.EvaluationWaitTime !== null) {
        contents.EvaluationWaitTime = deserializeAws_restJson1_1WaitTime(output.EvaluationWaitTime, context);
    }
    if (output.FalseActivity !== undefined && output.FalseActivity !== null) {
        contents.FalseActivity = output.FalseActivity;
    }
    if (output.TrueActivity !== undefined && output.TrueActivity !== null) {
        contents.TrueActivity = output.TrueActivity;
    }
    return contents;
};
const deserializeAws_restJson1_1CreateTemplateMessageBody = (output, context) => {
    let contents = {
        __type: "CreateTemplateMessageBody",
        Arn: undefined,
        Message: undefined,
        RequestID: undefined
    };
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.Message !== undefined && output.Message !== null) {
        contents.Message = output.Message;
    }
    if (output.RequestID !== undefined && output.RequestID !== null) {
        contents.RequestID = output.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1DefaultPushNotificationTemplate = (output, context) => {
    let contents = {
        __type: "DefaultPushNotificationTemplate",
        Action: undefined,
        Body: undefined,
        Sound: undefined,
        Title: undefined,
        Url: undefined
    };
    if (output.Action !== undefined && output.Action !== null) {
        contents.Action = output.Action;
    }
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.Sound !== undefined && output.Sound !== null) {
        contents.Sound = output.Sound;
    }
    if (output.Title !== undefined && output.Title !== null) {
        contents.Title = output.Title;
    }
    if (output.Url !== undefined && output.Url !== null) {
        contents.Url = output.Url;
    }
    return contents;
};
const deserializeAws_restJson1_1EmailChannelResponse = (output, context) => {
    let contents = {
        __type: "EmailChannelResponse",
        ApplicationId: undefined,
        ConfigurationSet: undefined,
        CreationDate: undefined,
        Enabled: undefined,
        FromAddress: undefined,
        HasCredential: undefined,
        Id: undefined,
        Identity: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        MessagesPerSecond: undefined,
        Platform: undefined,
        RoleArn: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.ConfigurationSet !== undefined &&
        output.ConfigurationSet !== null) {
        contents.ConfigurationSet = output.ConfigurationSet;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.FromAddress !== undefined && output.FromAddress !== null) {
        contents.FromAddress = output.FromAddress;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.Identity !== undefined && output.Identity !== null) {
        contents.Identity = output.Identity;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.MessagesPerSecond !== undefined &&
        output.MessagesPerSecond !== null) {
        contents.MessagesPerSecond = output.MessagesPerSecond;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.RoleArn !== undefined && output.RoleArn !== null) {
        contents.RoleArn = output.RoleArn;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1EmailMessageActivity = (output, context) => {
    let contents = {
        __type: "EmailMessageActivity",
        MessageConfig: undefined,
        NextActivity: undefined,
        TemplateName: undefined,
        TemplateVersion: undefined
    };
    if (output.MessageConfig !== undefined && output.MessageConfig !== null) {
        contents.MessageConfig = deserializeAws_restJson1_1JourneyEmailMessage(output.MessageConfig, context);
    }
    if (output.NextActivity !== undefined && output.NextActivity !== null) {
        contents.NextActivity = output.NextActivity;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateVersion !== undefined && output.TemplateVersion !== null) {
        contents.TemplateVersion = output.TemplateVersion;
    }
    return contents;
};
const deserializeAws_restJson1_1EmailTemplateResponse = (output, context) => {
    let contents = {
        __type: "EmailTemplateResponse",
        Arn: undefined,
        CreationDate: undefined,
        DefaultSubstitutions: undefined,
        HtmlPart: undefined,
        LastModifiedDate: undefined,
        Subject: undefined,
        TemplateDescription: undefined,
        TemplateName: undefined,
        TemplateType: undefined,
        TextPart: undefined,
        Version: undefined,
        tags: undefined
    };
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultSubstitutions !== undefined &&
        output.DefaultSubstitutions !== null) {
        contents.DefaultSubstitutions = output.DefaultSubstitutions;
    }
    if (output.HtmlPart !== undefined && output.HtmlPart !== null) {
        contents.HtmlPart = output.HtmlPart;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Subject !== undefined && output.Subject !== null) {
        contents.Subject = output.Subject;
    }
    if (output.TemplateDescription !== undefined &&
        output.TemplateDescription !== null) {
        contents.TemplateDescription = output.TemplateDescription;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateType !== undefined && output.TemplateType !== null) {
        contents.TemplateType = output.TemplateType;
    }
    if (output.TextPart !== undefined && output.TextPart !== null) {
        contents.TextPart = output.TextPart;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointDemographic = (output, context) => {
    let contents = {
        __type: "EndpointDemographic",
        AppVersion: undefined,
        Locale: undefined,
        Make: undefined,
        Model: undefined,
        ModelVersion: undefined,
        Platform: undefined,
        PlatformVersion: undefined,
        Timezone: undefined
    };
    if (output.AppVersion !== undefined && output.AppVersion !== null) {
        contents.AppVersion = output.AppVersion;
    }
    if (output.Locale !== undefined && output.Locale !== null) {
        contents.Locale = output.Locale;
    }
    if (output.Make !== undefined && output.Make !== null) {
        contents.Make = output.Make;
    }
    if (output.Model !== undefined && output.Model !== null) {
        contents.Model = output.Model;
    }
    if (output.ModelVersion !== undefined && output.ModelVersion !== null) {
        contents.ModelVersion = output.ModelVersion;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.PlatformVersion !== undefined && output.PlatformVersion !== null) {
        contents.PlatformVersion = output.PlatformVersion;
    }
    if (output.Timezone !== undefined && output.Timezone !== null) {
        contents.Timezone = output.Timezone;
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointItemResponse = (output, context) => {
    let contents = {
        __type: "EndpointItemResponse",
        Message: undefined,
        StatusCode: undefined
    };
    if (output.Message !== undefined && output.Message !== null) {
        contents.Message = output.Message;
    }
    if (output.StatusCode !== undefined && output.StatusCode !== null) {
        contents.StatusCode = output.StatusCode;
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointLocation = (output, context) => {
    let contents = {
        __type: "EndpointLocation",
        City: undefined,
        Country: undefined,
        Latitude: undefined,
        Longitude: undefined,
        PostalCode: undefined,
        Region: undefined
    };
    if (output.City !== undefined && output.City !== null) {
        contents.City = output.City;
    }
    if (output.Country !== undefined && output.Country !== null) {
        contents.Country = output.Country;
    }
    if (output.Latitude !== undefined && output.Latitude !== null) {
        contents.Latitude = output.Latitude;
    }
    if (output.Longitude !== undefined && output.Longitude !== null) {
        contents.Longitude = output.Longitude;
    }
    if (output.PostalCode !== undefined && output.PostalCode !== null) {
        contents.PostalCode = output.PostalCode;
    }
    if (output.Region !== undefined && output.Region !== null) {
        contents.Region = output.Region;
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointMessageResult = (output, context) => {
    let contents = {
        __type: "EndpointMessageResult",
        Address: undefined,
        DeliveryStatus: undefined,
        MessageId: undefined,
        StatusCode: undefined,
        StatusMessage: undefined,
        UpdatedToken: undefined
    };
    if (output.Address !== undefined && output.Address !== null) {
        contents.Address = output.Address;
    }
    if (output.DeliveryStatus !== undefined && output.DeliveryStatus !== null) {
        contents.DeliveryStatus = output.DeliveryStatus;
    }
    if (output.MessageId !== undefined && output.MessageId !== null) {
        contents.MessageId = output.MessageId;
    }
    if (output.StatusCode !== undefined && output.StatusCode !== null) {
        contents.StatusCode = output.StatusCode;
    }
    if (output.StatusMessage !== undefined && output.StatusMessage !== null) {
        contents.StatusMessage = output.StatusMessage;
    }
    if (output.UpdatedToken !== undefined && output.UpdatedToken !== null) {
        contents.UpdatedToken = output.UpdatedToken;
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointResponse = (output, context) => {
    let contents = {
        __type: "EndpointResponse",
        Address: undefined,
        ApplicationId: undefined,
        Attributes: undefined,
        ChannelType: undefined,
        CohortId: undefined,
        CreationDate: undefined,
        Demographic: undefined,
        EffectiveDate: undefined,
        EndpointStatus: undefined,
        Id: undefined,
        Location: undefined,
        Metrics: undefined,
        OptOut: undefined,
        RequestId: undefined,
        User: undefined
    };
    if (output.Address !== undefined && output.Address !== null) {
        contents.Address = output.Address;
    }
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.Attributes !== undefined && output.Attributes !== null) {
        contents.Attributes = deserializeAws_restJson1_1MapOfListOf__string(output.Attributes, context);
    }
    if (output.ChannelType !== undefined && output.ChannelType !== null) {
        contents.ChannelType = output.ChannelType;
    }
    if (output.CohortId !== undefined && output.CohortId !== null) {
        contents.CohortId = output.CohortId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Demographic !== undefined && output.Demographic !== null) {
        contents.Demographic = deserializeAws_restJson1_1EndpointDemographic(output.Demographic, context);
    }
    if (output.EffectiveDate !== undefined && output.EffectiveDate !== null) {
        contents.EffectiveDate = output.EffectiveDate;
    }
    if (output.EndpointStatus !== undefined && output.EndpointStatus !== null) {
        contents.EndpointStatus = output.EndpointStatus;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.Location !== undefined && output.Location !== null) {
        contents.Location = deserializeAws_restJson1_1EndpointLocation(output.Location, context);
    }
    if (output.Metrics !== undefined && output.Metrics !== null) {
        contents.Metrics = deserializeAws_restJson1_1MapOf__double(output.Metrics, context);
    }
    if (output.OptOut !== undefined && output.OptOut !== null) {
        contents.OptOut = output.OptOut;
    }
    if (output.RequestId !== undefined && output.RequestId !== null) {
        contents.RequestId = output.RequestId;
    }
    if (output.User !== undefined && output.User !== null) {
        contents.User = deserializeAws_restJson1_1EndpointUser(output.User, context);
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointUser = (output, context) => {
    let contents = {
        __type: "EndpointUser",
        UserAttributes: undefined,
        UserId: undefined
    };
    if (output.UserAttributes !== undefined && output.UserAttributes !== null) {
        contents.UserAttributes = deserializeAws_restJson1_1MapOfListOf__string(output.UserAttributes, context);
    }
    if (output.UserId !== undefined && output.UserId !== null) {
        contents.UserId = output.UserId;
    }
    return contents;
};
const deserializeAws_restJson1_1EndpointsResponse = (output, context) => {
    let contents = {
        __type: "EndpointsResponse",
        Item: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfEndpointResponse(output.Item, context);
    }
    return contents;
};
const deserializeAws_restJson1_1EventCondition = (output, context) => {
    let contents = {
        __type: "EventCondition",
        Dimensions: undefined,
        MessageActivity: undefined
    };
    if (output.Dimensions !== undefined && output.Dimensions !== null) {
        contents.Dimensions = deserializeAws_restJson1_1EventDimensions(output.Dimensions, context);
    }
    if (output.MessageActivity !== undefined && output.MessageActivity !== null) {
        contents.MessageActivity = output.MessageActivity;
    }
    return contents;
};
const deserializeAws_restJson1_1EventDimensions = (output, context) => {
    let contents = {
        __type: "EventDimensions",
        Attributes: undefined,
        EventType: undefined,
        Metrics: undefined
    };
    if (output.Attributes !== undefined && output.Attributes !== null) {
        contents.Attributes = deserializeAws_restJson1_1MapOfAttributeDimension(output.Attributes, context);
    }
    if (output.EventType !== undefined && output.EventType !== null) {
        contents.EventType = deserializeAws_restJson1_1SetDimension(output.EventType, context);
    }
    if (output.Metrics !== undefined && output.Metrics !== null) {
        contents.Metrics = deserializeAws_restJson1_1MapOfMetricDimension(output.Metrics, context);
    }
    return contents;
};
const deserializeAws_restJson1_1EventItemResponse = (output, context) => {
    let contents = {
        __type: "EventItemResponse",
        Message: undefined,
        StatusCode: undefined
    };
    if (output.Message !== undefined && output.Message !== null) {
        contents.Message = output.Message;
    }
    if (output.StatusCode !== undefined && output.StatusCode !== null) {
        contents.StatusCode = output.StatusCode;
    }
    return contents;
};
const deserializeAws_restJson1_1EventStream = (output, context) => {
    let contents = {
        __type: "EventStream",
        ApplicationId: undefined,
        DestinationStreamArn: undefined,
        ExternalId: undefined,
        LastModifiedDate: undefined,
        LastUpdatedBy: undefined,
        RoleArn: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.DestinationStreamArn !== undefined &&
        output.DestinationStreamArn !== null) {
        contents.DestinationStreamArn = output.DestinationStreamArn;
    }
    if (output.ExternalId !== undefined && output.ExternalId !== null) {
        contents.ExternalId = output.ExternalId;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.LastUpdatedBy !== undefined && output.LastUpdatedBy !== null) {
        contents.LastUpdatedBy = output.LastUpdatedBy;
    }
    if (output.RoleArn !== undefined && output.RoleArn !== null) {
        contents.RoleArn = output.RoleArn;
    }
    return contents;
};
const deserializeAws_restJson1_1EventsResponse = (output, context) => {
    let contents = {
        __type: "EventsResponse",
        Results: undefined
    };
    if (output.Results !== undefined && output.Results !== null) {
        contents.Results = deserializeAws_restJson1_1MapOfItemResponse(output.Results, context);
    }
    return contents;
};
const deserializeAws_restJson1_1ExportJobResource = (output, context) => {
    let contents = {
        __type: "ExportJobResource",
        RoleArn: undefined,
        S3UrlPrefix: undefined,
        SegmentId: undefined,
        SegmentVersion: undefined
    };
    if (output.RoleArn !== undefined && output.RoleArn !== null) {
        contents.RoleArn = output.RoleArn;
    }
    if (output.S3UrlPrefix !== undefined && output.S3UrlPrefix !== null) {
        contents.S3UrlPrefix = output.S3UrlPrefix;
    }
    if (output.SegmentId !== undefined && output.SegmentId !== null) {
        contents.SegmentId = output.SegmentId;
    }
    if (output.SegmentVersion !== undefined && output.SegmentVersion !== null) {
        contents.SegmentVersion = output.SegmentVersion;
    }
    return contents;
};
const deserializeAws_restJson1_1ExportJobResponse = (output, context) => {
    let contents = {
        __type: "ExportJobResponse",
        ApplicationId: undefined,
        CompletedPieces: undefined,
        CompletionDate: undefined,
        CreationDate: undefined,
        Definition: undefined,
        FailedPieces: undefined,
        Failures: undefined,
        Id: undefined,
        JobStatus: undefined,
        TotalFailures: undefined,
        TotalPieces: undefined,
        TotalProcessed: undefined,
        Type: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CompletedPieces !== undefined && output.CompletedPieces !== null) {
        contents.CompletedPieces = output.CompletedPieces;
    }
    if (output.CompletionDate !== undefined && output.CompletionDate !== null) {
        contents.CompletionDate = output.CompletionDate;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Definition !== undefined && output.Definition !== null) {
        contents.Definition = deserializeAws_restJson1_1ExportJobResource(output.Definition, context);
    }
    if (output.FailedPieces !== undefined && output.FailedPieces !== null) {
        contents.FailedPieces = output.FailedPieces;
    }
    if (output.Failures !== undefined && output.Failures !== null) {
        contents.Failures = deserializeAws_restJson1_1ListOf__string(output.Failures, context);
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.JobStatus !== undefined && output.JobStatus !== null) {
        contents.JobStatus = output.JobStatus;
    }
    if (output.TotalFailures !== undefined && output.TotalFailures !== null) {
        contents.TotalFailures = output.TotalFailures;
    }
    if (output.TotalPieces !== undefined && output.TotalPieces !== null) {
        contents.TotalPieces = output.TotalPieces;
    }
    if (output.TotalProcessed !== undefined && output.TotalProcessed !== null) {
        contents.TotalProcessed = output.TotalProcessed;
    }
    if (output.Type !== undefined && output.Type !== null) {
        contents.Type = output.Type;
    }
    return contents;
};
const deserializeAws_restJson1_1ExportJobsResponse = (output, context) => {
    let contents = {
        __type: "ExportJobsResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfExportJobResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1GCMChannelResponse = (output, context) => {
    let contents = {
        __type: "GCMChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        Credential: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Credential !== undefined && output.Credential !== null) {
        contents.Credential = output.Credential;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1GPSCoordinates = (output, context) => {
    let contents = {
        __type: "GPSCoordinates",
        Latitude: undefined,
        Longitude: undefined
    };
    if (output.Latitude !== undefined && output.Latitude !== null) {
        contents.Latitude = output.Latitude;
    }
    if (output.Longitude !== undefined && output.Longitude !== null) {
        contents.Longitude = output.Longitude;
    }
    return contents;
};
const deserializeAws_restJson1_1GPSPointDimension = (output, context) => {
    let contents = {
        __type: "GPSPointDimension",
        Coordinates: undefined,
        RangeInKilometers: undefined
    };
    if (output.Coordinates !== undefined && output.Coordinates !== null) {
        contents.Coordinates = deserializeAws_restJson1_1GPSCoordinates(output.Coordinates, context);
    }
    if (output.RangeInKilometers !== undefined &&
        output.RangeInKilometers !== null) {
        contents.RangeInKilometers = output.RangeInKilometers;
    }
    return contents;
};
const deserializeAws_restJson1_1HoldoutActivity = (output, context) => {
    let contents = {
        __type: "HoldoutActivity",
        NextActivity: undefined,
        Percentage: undefined
    };
    if (output.NextActivity !== undefined && output.NextActivity !== null) {
        contents.NextActivity = output.NextActivity;
    }
    if (output.Percentage !== undefined && output.Percentage !== null) {
        contents.Percentage = output.Percentage;
    }
    return contents;
};
const deserializeAws_restJson1_1ImportJobResource = (output, context) => {
    let contents = {
        __type: "ImportJobResource",
        DefineSegment: undefined,
        ExternalId: undefined,
        Format: undefined,
        RegisterEndpoints: undefined,
        RoleArn: undefined,
        S3Url: undefined,
        SegmentId: undefined,
        SegmentName: undefined
    };
    if (output.DefineSegment !== undefined && output.DefineSegment !== null) {
        contents.DefineSegment = output.DefineSegment;
    }
    if (output.ExternalId !== undefined && output.ExternalId !== null) {
        contents.ExternalId = output.ExternalId;
    }
    if (output.Format !== undefined && output.Format !== null) {
        contents.Format = output.Format;
    }
    if (output.RegisterEndpoints !== undefined &&
        output.RegisterEndpoints !== null) {
        contents.RegisterEndpoints = output.RegisterEndpoints;
    }
    if (output.RoleArn !== undefined && output.RoleArn !== null) {
        contents.RoleArn = output.RoleArn;
    }
    if (output.S3Url !== undefined && output.S3Url !== null) {
        contents.S3Url = output.S3Url;
    }
    if (output.SegmentId !== undefined && output.SegmentId !== null) {
        contents.SegmentId = output.SegmentId;
    }
    if (output.SegmentName !== undefined && output.SegmentName !== null) {
        contents.SegmentName = output.SegmentName;
    }
    return contents;
};
const deserializeAws_restJson1_1ImportJobResponse = (output, context) => {
    let contents = {
        __type: "ImportJobResponse",
        ApplicationId: undefined,
        CompletedPieces: undefined,
        CompletionDate: undefined,
        CreationDate: undefined,
        Definition: undefined,
        FailedPieces: undefined,
        Failures: undefined,
        Id: undefined,
        JobStatus: undefined,
        TotalFailures: undefined,
        TotalPieces: undefined,
        TotalProcessed: undefined,
        Type: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CompletedPieces !== undefined && output.CompletedPieces !== null) {
        contents.CompletedPieces = output.CompletedPieces;
    }
    if (output.CompletionDate !== undefined && output.CompletionDate !== null) {
        contents.CompletionDate = output.CompletionDate;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Definition !== undefined && output.Definition !== null) {
        contents.Definition = deserializeAws_restJson1_1ImportJobResource(output.Definition, context);
    }
    if (output.FailedPieces !== undefined && output.FailedPieces !== null) {
        contents.FailedPieces = output.FailedPieces;
    }
    if (output.Failures !== undefined && output.Failures !== null) {
        contents.Failures = deserializeAws_restJson1_1ListOf__string(output.Failures, context);
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.JobStatus !== undefined && output.JobStatus !== null) {
        contents.JobStatus = output.JobStatus;
    }
    if (output.TotalFailures !== undefined && output.TotalFailures !== null) {
        contents.TotalFailures = output.TotalFailures;
    }
    if (output.TotalPieces !== undefined && output.TotalPieces !== null) {
        contents.TotalPieces = output.TotalPieces;
    }
    if (output.TotalProcessed !== undefined && output.TotalProcessed !== null) {
        contents.TotalProcessed = output.TotalProcessed;
    }
    if (output.Type !== undefined && output.Type !== null) {
        contents.Type = output.Type;
    }
    return contents;
};
const deserializeAws_restJson1_1ImportJobsResponse = (output, context) => {
    let contents = {
        __type: "ImportJobsResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfImportJobResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1ItemResponse = (output, context) => {
    let contents = {
        __type: "ItemResponse",
        EndpointItemResponse: undefined,
        EventsItemResponse: undefined
    };
    if (output.EndpointItemResponse !== undefined &&
        output.EndpointItemResponse !== null) {
        contents.EndpointItemResponse = deserializeAws_restJson1_1EndpointItemResponse(output.EndpointItemResponse, context);
    }
    if (output.EventsItemResponse !== undefined &&
        output.EventsItemResponse !== null) {
        contents.EventsItemResponse = deserializeAws_restJson1_1MapOfEventItemResponse(output.EventsItemResponse, context);
    }
    return contents;
};
const deserializeAws_restJson1_1JourneyDateRangeKpiResponse = (output, context) => {
    let contents = {
        __type: "JourneyDateRangeKpiResponse",
        ApplicationId: undefined,
        EndTime: undefined,
        JourneyId: undefined,
        KpiName: undefined,
        KpiResult: undefined,
        NextToken: undefined,
        StartTime: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.EndTime !== undefined && output.EndTime !== null) {
        contents.EndTime = new Date(output.EndTime);
    }
    if (output.JourneyId !== undefined && output.JourneyId !== null) {
        contents.JourneyId = output.JourneyId;
    }
    if (output.KpiName !== undefined && output.KpiName !== null) {
        contents.KpiName = output.KpiName;
    }
    if (output.KpiResult !== undefined && output.KpiResult !== null) {
        contents.KpiResult = deserializeAws_restJson1_1BaseKpiResult(output.KpiResult, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    if (output.StartTime !== undefined && output.StartTime !== null) {
        contents.StartTime = new Date(output.StartTime);
    }
    return contents;
};
const deserializeAws_restJson1_1JourneyEmailMessage = (output, context) => {
    let contents = {
        __type: "JourneyEmailMessage",
        FromAddress: undefined
    };
    if (output.FromAddress !== undefined && output.FromAddress !== null) {
        contents.FromAddress = output.FromAddress;
    }
    return contents;
};
const deserializeAws_restJson1_1JourneyExecutionActivityMetricsResponse = (output, context) => {
    let contents = {
        __type: "JourneyExecutionActivityMetricsResponse",
        ActivityType: undefined,
        ApplicationId: undefined,
        JourneyActivityId: undefined,
        JourneyId: undefined,
        LastEvaluatedTime: undefined,
        Metrics: undefined
    };
    if (output.ActivityType !== undefined && output.ActivityType !== null) {
        contents.ActivityType = output.ActivityType;
    }
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.JourneyActivityId !== undefined &&
        output.JourneyActivityId !== null) {
        contents.JourneyActivityId = output.JourneyActivityId;
    }
    if (output.JourneyId !== undefined && output.JourneyId !== null) {
        contents.JourneyId = output.JourneyId;
    }
    if (output.LastEvaluatedTime !== undefined &&
        output.LastEvaluatedTime !== null) {
        contents.LastEvaluatedTime = output.LastEvaluatedTime;
    }
    if (output.Metrics !== undefined && output.Metrics !== null) {
        contents.Metrics = deserializeAws_restJson1_1MapOf__string(output.Metrics, context);
    }
    return contents;
};
const deserializeAws_restJson1_1JourneyExecutionMetricsResponse = (output, context) => {
    let contents = {
        __type: "JourneyExecutionMetricsResponse",
        ApplicationId: undefined,
        JourneyId: undefined,
        LastEvaluatedTime: undefined,
        Metrics: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.JourneyId !== undefined && output.JourneyId !== null) {
        contents.JourneyId = output.JourneyId;
    }
    if (output.LastEvaluatedTime !== undefined &&
        output.LastEvaluatedTime !== null) {
        contents.LastEvaluatedTime = output.LastEvaluatedTime;
    }
    if (output.Metrics !== undefined && output.Metrics !== null) {
        contents.Metrics = deserializeAws_restJson1_1MapOf__string(output.Metrics, context);
    }
    return contents;
};
const deserializeAws_restJson1_1JourneyLimits = (output, context) => {
    let contents = {
        __type: "JourneyLimits",
        DailyCap: undefined,
        EndpointReentryCap: undefined,
        MessagesPerSecond: undefined
    };
    if (output.DailyCap !== undefined && output.DailyCap !== null) {
        contents.DailyCap = output.DailyCap;
    }
    if (output.EndpointReentryCap !== undefined &&
        output.EndpointReentryCap !== null) {
        contents.EndpointReentryCap = output.EndpointReentryCap;
    }
    if (output.MessagesPerSecond !== undefined &&
        output.MessagesPerSecond !== null) {
        contents.MessagesPerSecond = output.MessagesPerSecond;
    }
    return contents;
};
const deserializeAws_restJson1_1JourneyResponse = (output, context) => {
    let contents = {
        __type: "JourneyResponse",
        Activities: undefined,
        ApplicationId: undefined,
        CreationDate: undefined,
        Id: undefined,
        LastModifiedDate: undefined,
        Limits: undefined,
        LocalTime: undefined,
        Name: undefined,
        QuietTime: undefined,
        RefreshFrequency: undefined,
        Schedule: undefined,
        StartActivity: undefined,
        StartCondition: undefined,
        State: undefined,
        tags: undefined
    };
    if (output.Activities !== undefined && output.Activities !== null) {
        contents.Activities = deserializeAws_restJson1_1MapOfActivity(output.Activities, context);
    }
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Limits !== undefined && output.Limits !== null) {
        contents.Limits = deserializeAws_restJson1_1JourneyLimits(output.Limits, context);
    }
    if (output.LocalTime !== undefined && output.LocalTime !== null) {
        contents.LocalTime = output.LocalTime;
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    if (output.QuietTime !== undefined && output.QuietTime !== null) {
        contents.QuietTime = deserializeAws_restJson1_1QuietTime(output.QuietTime, context);
    }
    if (output.RefreshFrequency !== undefined &&
        output.RefreshFrequency !== null) {
        contents.RefreshFrequency = output.RefreshFrequency;
    }
    if (output.Schedule !== undefined && output.Schedule !== null) {
        contents.Schedule = deserializeAws_restJson1_1JourneySchedule(output.Schedule, context);
    }
    if (output.StartActivity !== undefined && output.StartActivity !== null) {
        contents.StartActivity = output.StartActivity;
    }
    if (output.StartCondition !== undefined && output.StartCondition !== null) {
        contents.StartCondition = deserializeAws_restJson1_1StartCondition(output.StartCondition, context);
    }
    if (output.State !== undefined && output.State !== null) {
        contents.State = output.State;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1JourneySchedule = (output, context) => {
    let contents = {
        __type: "JourneySchedule",
        EndTime: undefined,
        StartTime: undefined,
        Timezone: undefined
    };
    if (output.EndTime !== undefined && output.EndTime !== null) {
        contents.EndTime = new Date(output.EndTime);
    }
    if (output.StartTime !== undefined && output.StartTime !== null) {
        contents.StartTime = new Date(output.StartTime);
    }
    if (output.Timezone !== undefined && output.Timezone !== null) {
        contents.Timezone = output.Timezone;
    }
    return contents;
};
const deserializeAws_restJson1_1JourneysResponse = (output, context) => {
    let contents = {
        __type: "JourneysResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfJourneyResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1ListOfActivityResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1ActivityResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfApplicationResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1ApplicationResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfCampaignResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1CampaignResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfEndpointResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1EndpointResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfExportJobResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1ExportJobResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfImportJobResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1ImportJobResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfJourneyResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1JourneyResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfMultiConditionalBranch = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1MultiConditionalBranch(entry, context));
};
const deserializeAws_restJson1_1ListOfRandomSplitEntry = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1RandomSplitEntry(entry, context));
};
const deserializeAws_restJson1_1ListOfResultRow = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1ResultRow(entry, context));
};
const deserializeAws_restJson1_1ListOfResultRowValue = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1ResultRowValue(entry, context));
};
const deserializeAws_restJson1_1ListOfSegmentDimensions = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1SegmentDimensions(entry, context));
};
const deserializeAws_restJson1_1ListOfSegmentGroup = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1SegmentGroup(entry, context));
};
const deserializeAws_restJson1_1ListOfSegmentReference = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1SegmentReference(entry, context));
};
const deserializeAws_restJson1_1ListOfSegmentResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1SegmentResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfSimpleCondition = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1SimpleCondition(entry, context));
};
const deserializeAws_restJson1_1ListOfTemplateResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1TemplateResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfTemplateVersionResponse = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1TemplateVersionResponse(entry, context));
};
const deserializeAws_restJson1_1ListOfTreatmentResource = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1TreatmentResource(entry, context));
};
const deserializeAws_restJson1_1ListOf__string = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_restJson1_1MapOfActivity = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1Activity(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfAttributeDimension = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1AttributeDimension(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfChannelResponse = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1ChannelResponse(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfEndpointMessageResult = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1EndpointMessageResult(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfEventItemResponse = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1EventItemResponse(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfItemResponse = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1ItemResponse(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfListOf__string = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1ListOf__string(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfMapOfEndpointMessageResult = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1MapOfEndpointMessageResult(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfMessageResult = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1MessageResult(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOfMetricDimension = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = deserializeAws_restJson1_1MetricDimension(output[key], context);
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOf__double = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = output[key];
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOf__integer = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = output[key];
    });
    return mapParams;
};
const deserializeAws_restJson1_1MapOf__string = (output, context) => {
    const mapParams = {};
    Object.keys(output).forEach(key => {
        mapParams[key] = output[key];
    });
    return mapParams;
};
const deserializeAws_restJson1_1Message = (output, context) => {
    let contents = {
        __type: "Message",
        Action: undefined,
        Body: undefined,
        ImageIconUrl: undefined,
        ImageSmallIconUrl: undefined,
        ImageUrl: undefined,
        JsonBody: undefined,
        MediaUrl: undefined,
        RawContent: undefined,
        SilentPush: undefined,
        TimeToLive: undefined,
        Title: undefined,
        Url: undefined
    };
    if (output.Action !== undefined && output.Action !== null) {
        contents.Action = output.Action;
    }
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.ImageIconUrl !== undefined && output.ImageIconUrl !== null) {
        contents.ImageIconUrl = output.ImageIconUrl;
    }
    if (output.ImageSmallIconUrl !== undefined &&
        output.ImageSmallIconUrl !== null) {
        contents.ImageSmallIconUrl = output.ImageSmallIconUrl;
    }
    if (output.ImageUrl !== undefined && output.ImageUrl !== null) {
        contents.ImageUrl = output.ImageUrl;
    }
    if (output.JsonBody !== undefined && output.JsonBody !== null) {
        contents.JsonBody = output.JsonBody;
    }
    if (output.MediaUrl !== undefined && output.MediaUrl !== null) {
        contents.MediaUrl = output.MediaUrl;
    }
    if (output.RawContent !== undefined && output.RawContent !== null) {
        contents.RawContent = output.RawContent;
    }
    if (output.SilentPush !== undefined && output.SilentPush !== null) {
        contents.SilentPush = output.SilentPush;
    }
    if (output.TimeToLive !== undefined && output.TimeToLive !== null) {
        contents.TimeToLive = output.TimeToLive;
    }
    if (output.Title !== undefined && output.Title !== null) {
        contents.Title = output.Title;
    }
    if (output.Url !== undefined && output.Url !== null) {
        contents.Url = output.Url;
    }
    return contents;
};
const deserializeAws_restJson1_1MessageBody = (output, context) => {
    let contents = {
        __type: "MessageBody",
        Message: undefined,
        RequestID: undefined
    };
    if (output.Message !== undefined && output.Message !== null) {
        contents.Message = output.Message;
    }
    if (output.RequestID !== undefined && output.RequestID !== null) {
        contents.RequestID = output.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1MessageConfiguration = (output, context) => {
    let contents = {
        __type: "MessageConfiguration",
        ADMMessage: undefined,
        APNSMessage: undefined,
        BaiduMessage: undefined,
        DefaultMessage: undefined,
        EmailMessage: undefined,
        GCMMessage: undefined,
        SMSMessage: undefined
    };
    if (output.ADMMessage !== undefined && output.ADMMessage !== null) {
        contents.ADMMessage = deserializeAws_restJson1_1Message(output.ADMMessage, context);
    }
    if (output.APNSMessage !== undefined && output.APNSMessage !== null) {
        contents.APNSMessage = deserializeAws_restJson1_1Message(output.APNSMessage, context);
    }
    if (output.BaiduMessage !== undefined && output.BaiduMessage !== null) {
        contents.BaiduMessage = deserializeAws_restJson1_1Message(output.BaiduMessage, context);
    }
    if (output.DefaultMessage !== undefined && output.DefaultMessage !== null) {
        contents.DefaultMessage = deserializeAws_restJson1_1Message(output.DefaultMessage, context);
    }
    if (output.EmailMessage !== undefined && output.EmailMessage !== null) {
        contents.EmailMessage = deserializeAws_restJson1_1CampaignEmailMessage(output.EmailMessage, context);
    }
    if (output.GCMMessage !== undefined && output.GCMMessage !== null) {
        contents.GCMMessage = deserializeAws_restJson1_1Message(output.GCMMessage, context);
    }
    if (output.SMSMessage !== undefined && output.SMSMessage !== null) {
        contents.SMSMessage = deserializeAws_restJson1_1CampaignSmsMessage(output.SMSMessage, context);
    }
    return contents;
};
const deserializeAws_restJson1_1MessageResponse = (output, context) => {
    let contents = {
        __type: "MessageResponse",
        ApplicationId: undefined,
        EndpointResult: undefined,
        RequestId: undefined,
        Result: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.EndpointResult !== undefined && output.EndpointResult !== null) {
        contents.EndpointResult = deserializeAws_restJson1_1MapOfEndpointMessageResult(output.EndpointResult, context);
    }
    if (output.RequestId !== undefined && output.RequestId !== null) {
        contents.RequestId = output.RequestId;
    }
    if (output.Result !== undefined && output.Result !== null) {
        contents.Result = deserializeAws_restJson1_1MapOfMessageResult(output.Result, context);
    }
    return contents;
};
const deserializeAws_restJson1_1MessageResult = (output, context) => {
    let contents = {
        __type: "MessageResult",
        DeliveryStatus: undefined,
        MessageId: undefined,
        StatusCode: undefined,
        StatusMessage: undefined,
        UpdatedToken: undefined
    };
    if (output.DeliveryStatus !== undefined && output.DeliveryStatus !== null) {
        contents.DeliveryStatus = output.DeliveryStatus;
    }
    if (output.MessageId !== undefined && output.MessageId !== null) {
        contents.MessageId = output.MessageId;
    }
    if (output.StatusCode !== undefined && output.StatusCode !== null) {
        contents.StatusCode = output.StatusCode;
    }
    if (output.StatusMessage !== undefined && output.StatusMessage !== null) {
        contents.StatusMessage = output.StatusMessage;
    }
    if (output.UpdatedToken !== undefined && output.UpdatedToken !== null) {
        contents.UpdatedToken = output.UpdatedToken;
    }
    return contents;
};
const deserializeAws_restJson1_1MetricDimension = (output, context) => {
    let contents = {
        __type: "MetricDimension",
        ComparisonOperator: undefined,
        Value: undefined
    };
    if (output.ComparisonOperator !== undefined &&
        output.ComparisonOperator !== null) {
        contents.ComparisonOperator = output.ComparisonOperator;
    }
    if (output.Value !== undefined && output.Value !== null) {
        contents.Value = output.Value;
    }
    return contents;
};
const deserializeAws_restJson1_1MultiConditionalBranch = (output, context) => {
    let contents = {
        __type: "MultiConditionalBranch",
        Condition: undefined,
        NextActivity: undefined
    };
    if (output.Condition !== undefined && output.Condition !== null) {
        contents.Condition = deserializeAws_restJson1_1SimpleCondition(output.Condition, context);
    }
    if (output.NextActivity !== undefined && output.NextActivity !== null) {
        contents.NextActivity = output.NextActivity;
    }
    return contents;
};
const deserializeAws_restJson1_1MultiConditionalSplitActivity = (output, context) => {
    let contents = {
        __type: "MultiConditionalSplitActivity",
        Branches: undefined,
        DefaultActivity: undefined,
        EvaluationWaitTime: undefined
    };
    if (output.Branches !== undefined && output.Branches !== null) {
        contents.Branches = deserializeAws_restJson1_1ListOfMultiConditionalBranch(output.Branches, context);
    }
    if (output.DefaultActivity !== undefined && output.DefaultActivity !== null) {
        contents.DefaultActivity = output.DefaultActivity;
    }
    if (output.EvaluationWaitTime !== undefined &&
        output.EvaluationWaitTime !== null) {
        contents.EvaluationWaitTime = deserializeAws_restJson1_1WaitTime(output.EvaluationWaitTime, context);
    }
    return contents;
};
const deserializeAws_restJson1_1NumberValidateResponse = (output, context) => {
    let contents = {
        __type: "NumberValidateResponse",
        Carrier: undefined,
        City: undefined,
        CleansedPhoneNumberE164: undefined,
        CleansedPhoneNumberNational: undefined,
        Country: undefined,
        CountryCodeIso2: undefined,
        CountryCodeNumeric: undefined,
        County: undefined,
        OriginalCountryCodeIso2: undefined,
        OriginalPhoneNumber: undefined,
        PhoneType: undefined,
        PhoneTypeCode: undefined,
        Timezone: undefined,
        ZipCode: undefined
    };
    if (output.Carrier !== undefined && output.Carrier !== null) {
        contents.Carrier = output.Carrier;
    }
    if (output.City !== undefined && output.City !== null) {
        contents.City = output.City;
    }
    if (output.CleansedPhoneNumberE164 !== undefined &&
        output.CleansedPhoneNumberE164 !== null) {
        contents.CleansedPhoneNumberE164 = output.CleansedPhoneNumberE164;
    }
    if (output.CleansedPhoneNumberNational !== undefined &&
        output.CleansedPhoneNumberNational !== null) {
        contents.CleansedPhoneNumberNational = output.CleansedPhoneNumberNational;
    }
    if (output.Country !== undefined && output.Country !== null) {
        contents.Country = output.Country;
    }
    if (output.CountryCodeIso2 !== undefined && output.CountryCodeIso2 !== null) {
        contents.CountryCodeIso2 = output.CountryCodeIso2;
    }
    if (output.CountryCodeNumeric !== undefined &&
        output.CountryCodeNumeric !== null) {
        contents.CountryCodeNumeric = output.CountryCodeNumeric;
    }
    if (output.County !== undefined && output.County !== null) {
        contents.County = output.County;
    }
    if (output.OriginalCountryCodeIso2 !== undefined &&
        output.OriginalCountryCodeIso2 !== null) {
        contents.OriginalCountryCodeIso2 = output.OriginalCountryCodeIso2;
    }
    if (output.OriginalPhoneNumber !== undefined &&
        output.OriginalPhoneNumber !== null) {
        contents.OriginalPhoneNumber = output.OriginalPhoneNumber;
    }
    if (output.PhoneType !== undefined && output.PhoneType !== null) {
        contents.PhoneType = output.PhoneType;
    }
    if (output.PhoneTypeCode !== undefined && output.PhoneTypeCode !== null) {
        contents.PhoneTypeCode = output.PhoneTypeCode;
    }
    if (output.Timezone !== undefined && output.Timezone !== null) {
        contents.Timezone = output.Timezone;
    }
    if (output.ZipCode !== undefined && output.ZipCode !== null) {
        contents.ZipCode = output.ZipCode;
    }
    return contents;
};
const deserializeAws_restJson1_1PushNotificationTemplateResponse = (output, context) => {
    let contents = {
        __type: "PushNotificationTemplateResponse",
        ADM: undefined,
        APNS: undefined,
        Arn: undefined,
        Baidu: undefined,
        CreationDate: undefined,
        Default: undefined,
        DefaultSubstitutions: undefined,
        GCM: undefined,
        LastModifiedDate: undefined,
        TemplateDescription: undefined,
        TemplateName: undefined,
        TemplateType: undefined,
        Version: undefined,
        tags: undefined
    };
    if (output.ADM !== undefined && output.ADM !== null) {
        contents.ADM = deserializeAws_restJson1_1AndroidPushNotificationTemplate(output.ADM, context);
    }
    if (output.APNS !== undefined && output.APNS !== null) {
        contents.APNS = deserializeAws_restJson1_1APNSPushNotificationTemplate(output.APNS, context);
    }
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.Baidu !== undefined && output.Baidu !== null) {
        contents.Baidu = deserializeAws_restJson1_1AndroidPushNotificationTemplate(output.Baidu, context);
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Default !== undefined && output.Default !== null) {
        contents.Default = deserializeAws_restJson1_1DefaultPushNotificationTemplate(output.Default, context);
    }
    if (output.DefaultSubstitutions !== undefined &&
        output.DefaultSubstitutions !== null) {
        contents.DefaultSubstitutions = output.DefaultSubstitutions;
    }
    if (output.GCM !== undefined && output.GCM !== null) {
        contents.GCM = deserializeAws_restJson1_1AndroidPushNotificationTemplate(output.GCM, context);
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.TemplateDescription !== undefined &&
        output.TemplateDescription !== null) {
        contents.TemplateDescription = output.TemplateDescription;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateType !== undefined && output.TemplateType !== null) {
        contents.TemplateType = output.TemplateType;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1QuietTime = (output, context) => {
    let contents = {
        __type: "QuietTime",
        End: undefined,
        Start: undefined
    };
    if (output.End !== undefined && output.End !== null) {
        contents.End = output.End;
    }
    if (output.Start !== undefined && output.Start !== null) {
        contents.Start = output.Start;
    }
    return contents;
};
const deserializeAws_restJson1_1RandomSplitActivity = (output, context) => {
    let contents = {
        __type: "RandomSplitActivity",
        Branches: undefined
    };
    if (output.Branches !== undefined && output.Branches !== null) {
        contents.Branches = deserializeAws_restJson1_1ListOfRandomSplitEntry(output.Branches, context);
    }
    return contents;
};
const deserializeAws_restJson1_1RandomSplitEntry = (output, context) => {
    let contents = {
        __type: "RandomSplitEntry",
        NextActivity: undefined,
        Percentage: undefined
    };
    if (output.NextActivity !== undefined && output.NextActivity !== null) {
        contents.NextActivity = output.NextActivity;
    }
    if (output.Percentage !== undefined && output.Percentage !== null) {
        contents.Percentage = output.Percentage;
    }
    return contents;
};
const deserializeAws_restJson1_1RecencyDimension = (output, context) => {
    let contents = {
        __type: "RecencyDimension",
        Duration: undefined,
        RecencyType: undefined
    };
    if (output.Duration !== undefined && output.Duration !== null) {
        contents.Duration = output.Duration;
    }
    if (output.RecencyType !== undefined && output.RecencyType !== null) {
        contents.RecencyType = output.RecencyType;
    }
    return contents;
};
const deserializeAws_restJson1_1ResultRow = (output, context) => {
    let contents = {
        __type: "ResultRow",
        GroupedBys: undefined,
        Values: undefined
    };
    if (output.GroupedBys !== undefined && output.GroupedBys !== null) {
        contents.GroupedBys = deserializeAws_restJson1_1ListOfResultRowValue(output.GroupedBys, context);
    }
    if (output.Values !== undefined && output.Values !== null) {
        contents.Values = deserializeAws_restJson1_1ListOfResultRowValue(output.Values, context);
    }
    return contents;
};
const deserializeAws_restJson1_1ResultRowValue = (output, context) => {
    let contents = {
        __type: "ResultRowValue",
        Key: undefined,
        Type: undefined,
        Value: undefined
    };
    if (output.Key !== undefined && output.Key !== null) {
        contents.Key = output.Key;
    }
    if (output.Type !== undefined && output.Type !== null) {
        contents.Type = output.Type;
    }
    if (output.Value !== undefined && output.Value !== null) {
        contents.Value = output.Value;
    }
    return contents;
};
const deserializeAws_restJson1_1SMSChannelResponse = (output, context) => {
    let contents = {
        __type: "SMSChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        PromotionalMessagesPerSecond: undefined,
        SenderId: undefined,
        ShortCode: undefined,
        TransactionalMessagesPerSecond: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.PromotionalMessagesPerSecond !== undefined &&
        output.PromotionalMessagesPerSecond !== null) {
        contents.PromotionalMessagesPerSecond = output.PromotionalMessagesPerSecond;
    }
    if (output.SenderId !== undefined && output.SenderId !== null) {
        contents.SenderId = output.SenderId;
    }
    if (output.ShortCode !== undefined && output.ShortCode !== null) {
        contents.ShortCode = output.ShortCode;
    }
    if (output.TransactionalMessagesPerSecond !== undefined &&
        output.TransactionalMessagesPerSecond !== null) {
        contents.TransactionalMessagesPerSecond =
            output.TransactionalMessagesPerSecond;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1SMSTemplateResponse = (output, context) => {
    let contents = {
        __type: "SMSTemplateResponse",
        Arn: undefined,
        Body: undefined,
        CreationDate: undefined,
        DefaultSubstitutions: undefined,
        LastModifiedDate: undefined,
        TemplateDescription: undefined,
        TemplateName: undefined,
        TemplateType: undefined,
        Version: undefined,
        tags: undefined
    };
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultSubstitutions !== undefined &&
        output.DefaultSubstitutions !== null) {
        contents.DefaultSubstitutions = output.DefaultSubstitutions;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.TemplateDescription !== undefined &&
        output.TemplateDescription !== null) {
        contents.TemplateDescription = output.TemplateDescription;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateType !== undefined && output.TemplateType !== null) {
        contents.TemplateType = output.TemplateType;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1Schedule = (output, context) => {
    let contents = {
        __type: "Schedule",
        EndTime: undefined,
        EventFilter: undefined,
        Frequency: undefined,
        IsLocalTime: undefined,
        QuietTime: undefined,
        StartTime: undefined,
        Timezone: undefined
    };
    if (output.EndTime !== undefined && output.EndTime !== null) {
        contents.EndTime = output.EndTime;
    }
    if (output.EventFilter !== undefined && output.EventFilter !== null) {
        contents.EventFilter = deserializeAws_restJson1_1CampaignEventFilter(output.EventFilter, context);
    }
    if (output.Frequency !== undefined && output.Frequency !== null) {
        contents.Frequency = output.Frequency;
    }
    if (output.IsLocalTime !== undefined && output.IsLocalTime !== null) {
        contents.IsLocalTime = output.IsLocalTime;
    }
    if (output.QuietTime !== undefined && output.QuietTime !== null) {
        contents.QuietTime = deserializeAws_restJson1_1QuietTime(output.QuietTime, context);
    }
    if (output.StartTime !== undefined && output.StartTime !== null) {
        contents.StartTime = output.StartTime;
    }
    if (output.Timezone !== undefined && output.Timezone !== null) {
        contents.Timezone = output.Timezone;
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentBehaviors = (output, context) => {
    let contents = {
        __type: "SegmentBehaviors",
        Recency: undefined
    };
    if (output.Recency !== undefined && output.Recency !== null) {
        contents.Recency = deserializeAws_restJson1_1RecencyDimension(output.Recency, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentCondition = (output, context) => {
    let contents = {
        __type: "SegmentCondition",
        SegmentId: undefined
    };
    if (output.SegmentId !== undefined && output.SegmentId !== null) {
        contents.SegmentId = output.SegmentId;
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentDemographics = (output, context) => {
    let contents = {
        __type: "SegmentDemographics",
        AppVersion: undefined,
        Channel: undefined,
        DeviceType: undefined,
        Make: undefined,
        Model: undefined,
        Platform: undefined
    };
    if (output.AppVersion !== undefined && output.AppVersion !== null) {
        contents.AppVersion = deserializeAws_restJson1_1SetDimension(output.AppVersion, context);
    }
    if (output.Channel !== undefined && output.Channel !== null) {
        contents.Channel = deserializeAws_restJson1_1SetDimension(output.Channel, context);
    }
    if (output.DeviceType !== undefined && output.DeviceType !== null) {
        contents.DeviceType = deserializeAws_restJson1_1SetDimension(output.DeviceType, context);
    }
    if (output.Make !== undefined && output.Make !== null) {
        contents.Make = deserializeAws_restJson1_1SetDimension(output.Make, context);
    }
    if (output.Model !== undefined && output.Model !== null) {
        contents.Model = deserializeAws_restJson1_1SetDimension(output.Model, context);
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = deserializeAws_restJson1_1SetDimension(output.Platform, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentDimensions = (output, context) => {
    let contents = {
        __type: "SegmentDimensions",
        Attributes: undefined,
        Behavior: undefined,
        Demographic: undefined,
        Location: undefined,
        Metrics: undefined,
        UserAttributes: undefined
    };
    if (output.Attributes !== undefined && output.Attributes !== null) {
        contents.Attributes = deserializeAws_restJson1_1MapOfAttributeDimension(output.Attributes, context);
    }
    if (output.Behavior !== undefined && output.Behavior !== null) {
        contents.Behavior = deserializeAws_restJson1_1SegmentBehaviors(output.Behavior, context);
    }
    if (output.Demographic !== undefined && output.Demographic !== null) {
        contents.Demographic = deserializeAws_restJson1_1SegmentDemographics(output.Demographic, context);
    }
    if (output.Location !== undefined && output.Location !== null) {
        contents.Location = deserializeAws_restJson1_1SegmentLocation(output.Location, context);
    }
    if (output.Metrics !== undefined && output.Metrics !== null) {
        contents.Metrics = deserializeAws_restJson1_1MapOfMetricDimension(output.Metrics, context);
    }
    if (output.UserAttributes !== undefined && output.UserAttributes !== null) {
        contents.UserAttributes = deserializeAws_restJson1_1MapOfAttributeDimension(output.UserAttributes, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentGroup = (output, context) => {
    let contents = {
        __type: "SegmentGroup",
        Dimensions: undefined,
        SourceSegments: undefined,
        SourceType: undefined,
        Type: undefined
    };
    if (output.Dimensions !== undefined && output.Dimensions !== null) {
        contents.Dimensions = deserializeAws_restJson1_1ListOfSegmentDimensions(output.Dimensions, context);
    }
    if (output.SourceSegments !== undefined && output.SourceSegments !== null) {
        contents.SourceSegments = deserializeAws_restJson1_1ListOfSegmentReference(output.SourceSegments, context);
    }
    if (output.SourceType !== undefined && output.SourceType !== null) {
        contents.SourceType = output.SourceType;
    }
    if (output.Type !== undefined && output.Type !== null) {
        contents.Type = output.Type;
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentGroupList = (output, context) => {
    let contents = {
        __type: "SegmentGroupList",
        Groups: undefined,
        Include: undefined
    };
    if (output.Groups !== undefined && output.Groups !== null) {
        contents.Groups = deserializeAws_restJson1_1ListOfSegmentGroup(output.Groups, context);
    }
    if (output.Include !== undefined && output.Include !== null) {
        contents.Include = output.Include;
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentImportResource = (output, context) => {
    let contents = {
        __type: "SegmentImportResource",
        ChannelCounts: undefined,
        ExternalId: undefined,
        Format: undefined,
        RoleArn: undefined,
        S3Url: undefined,
        Size: undefined
    };
    if (output.ChannelCounts !== undefined && output.ChannelCounts !== null) {
        contents.ChannelCounts = deserializeAws_restJson1_1MapOf__integer(output.ChannelCounts, context);
    }
    if (output.ExternalId !== undefined && output.ExternalId !== null) {
        contents.ExternalId = output.ExternalId;
    }
    if (output.Format !== undefined && output.Format !== null) {
        contents.Format = output.Format;
    }
    if (output.RoleArn !== undefined && output.RoleArn !== null) {
        contents.RoleArn = output.RoleArn;
    }
    if (output.S3Url !== undefined && output.S3Url !== null) {
        contents.S3Url = output.S3Url;
    }
    if (output.Size !== undefined && output.Size !== null) {
        contents.Size = output.Size;
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentLocation = (output, context) => {
    let contents = {
        __type: "SegmentLocation",
        Country: undefined,
        GPSPoint: undefined
    };
    if (output.Country !== undefined && output.Country !== null) {
        contents.Country = deserializeAws_restJson1_1SetDimension(output.Country, context);
    }
    if (output.GPSPoint !== undefined && output.GPSPoint !== null) {
        contents.GPSPoint = deserializeAws_restJson1_1GPSPointDimension(output.GPSPoint, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentReference = (output, context) => {
    let contents = {
        __type: "SegmentReference",
        Id: undefined,
        Version: undefined
    };
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentResponse = (output, context) => {
    let contents = {
        __type: "SegmentResponse",
        ApplicationId: undefined,
        Arn: undefined,
        CreationDate: undefined,
        Dimensions: undefined,
        Id: undefined,
        ImportDefinition: undefined,
        LastModifiedDate: undefined,
        Name: undefined,
        SegmentGroups: undefined,
        SegmentType: undefined,
        Version: undefined,
        tags: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Dimensions !== undefined && output.Dimensions !== null) {
        contents.Dimensions = deserializeAws_restJson1_1SegmentDimensions(output.Dimensions, context);
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.ImportDefinition !== undefined &&
        output.ImportDefinition !== null) {
        contents.ImportDefinition = deserializeAws_restJson1_1SegmentImportResource(output.ImportDefinition, context);
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    if (output.SegmentGroups !== undefined && output.SegmentGroups !== null) {
        contents.SegmentGroups = deserializeAws_restJson1_1SegmentGroupList(output.SegmentGroups, context);
    }
    if (output.SegmentType !== undefined && output.SegmentType !== null) {
        contents.SegmentType = output.SegmentType;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SegmentsResponse = (output, context) => {
    let contents = {
        __type: "SegmentsResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfSegmentResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1SendUsersMessageResponse = (output, context) => {
    let contents = {
        __type: "SendUsersMessageResponse",
        ApplicationId: undefined,
        RequestId: undefined,
        Result: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.RequestId !== undefined && output.RequestId !== null) {
        contents.RequestId = output.RequestId;
    }
    if (output.Result !== undefined && output.Result !== null) {
        contents.Result = deserializeAws_restJson1_1MapOfMapOfEndpointMessageResult(output.Result, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SetDimension = (output, context) => {
    let contents = {
        __type: "SetDimension",
        DimensionType: undefined,
        Values: undefined
    };
    if (output.DimensionType !== undefined && output.DimensionType !== null) {
        contents.DimensionType = output.DimensionType;
    }
    if (output.Values !== undefined && output.Values !== null) {
        contents.Values = deserializeAws_restJson1_1ListOf__string(output.Values, context);
    }
    return contents;
};
const deserializeAws_restJson1_1SimpleCondition = (output, context) => {
    let contents = {
        __type: "SimpleCondition",
        EventCondition: undefined,
        SegmentCondition: undefined,
        SegmentDimensions: undefined
    };
    if (output.EventCondition !== undefined && output.EventCondition !== null) {
        contents.EventCondition = deserializeAws_restJson1_1EventCondition(output.EventCondition, context);
    }
    if (output.SegmentCondition !== undefined &&
        output.SegmentCondition !== null) {
        contents.SegmentCondition = deserializeAws_restJson1_1SegmentCondition(output.SegmentCondition, context);
    }
    if (output.segmentDimensions !== undefined &&
        output.segmentDimensions !== null) {
        contents.SegmentDimensions = deserializeAws_restJson1_1SegmentDimensions(output.segmentDimensions, context);
    }
    return contents;
};
const deserializeAws_restJson1_1StartCondition = (output, context) => {
    let contents = {
        __type: "StartCondition",
        Description: undefined,
        SegmentStartCondition: undefined
    };
    if (output.Description !== undefined && output.Description !== null) {
        contents.Description = output.Description;
    }
    if (output.SegmentStartCondition !== undefined &&
        output.SegmentStartCondition !== null) {
        contents.SegmentStartCondition = deserializeAws_restJson1_1SegmentCondition(output.SegmentStartCondition, context);
    }
    return contents;
};
const deserializeAws_restJson1_1TagsModel = (output, context) => {
    let contents = {
        __type: "TagsModel",
        tags: undefined
    };
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1Template = (output, context) => {
    let contents = {
        __type: "Template",
        Name: undefined,
        Version: undefined
    };
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1TemplateConfiguration = (output, context) => {
    let contents = {
        __type: "TemplateConfiguration",
        EmailTemplate: undefined,
        PushTemplate: undefined,
        SMSTemplate: undefined,
        VoiceTemplate: undefined
    };
    if (output.EmailTemplate !== undefined && output.EmailTemplate !== null) {
        contents.EmailTemplate = deserializeAws_restJson1_1Template(output.EmailTemplate, context);
    }
    if (output.PushTemplate !== undefined && output.PushTemplate !== null) {
        contents.PushTemplate = deserializeAws_restJson1_1Template(output.PushTemplate, context);
    }
    if (output.SMSTemplate !== undefined && output.SMSTemplate !== null) {
        contents.SMSTemplate = deserializeAws_restJson1_1Template(output.SMSTemplate, context);
    }
    if (output.VoiceTemplate !== undefined && output.VoiceTemplate !== null) {
        contents.VoiceTemplate = deserializeAws_restJson1_1Template(output.VoiceTemplate, context);
    }
    return contents;
};
const deserializeAws_restJson1_1TemplateResponse = (output, context) => {
    let contents = {
        __type: "TemplateResponse",
        Arn: undefined,
        CreationDate: undefined,
        DefaultSubstitutions: undefined,
        LastModifiedDate: undefined,
        TemplateDescription: undefined,
        TemplateName: undefined,
        TemplateType: undefined,
        Version: undefined,
        tags: undefined
    };
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultSubstitutions !== undefined &&
        output.DefaultSubstitutions !== null) {
        contents.DefaultSubstitutions = output.DefaultSubstitutions;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.TemplateDescription !== undefined &&
        output.TemplateDescription !== null) {
        contents.TemplateDescription = output.TemplateDescription;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateType !== undefined && output.TemplateType !== null) {
        contents.TemplateType = output.TemplateType;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1TemplateVersionResponse = (output, context) => {
    let contents = {
        __type: "TemplateVersionResponse",
        CreationDate: undefined,
        DefaultSubstitutions: undefined,
        LastModifiedDate: undefined,
        TemplateDescription: undefined,
        TemplateName: undefined,
        TemplateType: undefined,
        Version: undefined
    };
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultSubstitutions !== undefined &&
        output.DefaultSubstitutions !== null) {
        contents.DefaultSubstitutions = output.DefaultSubstitutions;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.TemplateDescription !== undefined &&
        output.TemplateDescription !== null) {
        contents.TemplateDescription = output.TemplateDescription;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateType !== undefined && output.TemplateType !== null) {
        contents.TemplateType = output.TemplateType;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1TemplateVersionsResponse = (output, context) => {
    let contents = {
        __type: "TemplateVersionsResponse",
        Item: undefined,
        Message: undefined,
        NextToken: undefined,
        RequestID: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfTemplateVersionResponse(output.Item, context);
    }
    if (output.Message !== undefined && output.Message !== null) {
        contents.Message = output.Message;
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    if (output.RequestID !== undefined && output.RequestID !== null) {
        contents.RequestID = output.RequestID;
    }
    return contents;
};
const deserializeAws_restJson1_1TemplatesResponse = (output, context) => {
    let contents = {
        __type: "TemplatesResponse",
        Item: undefined,
        NextToken: undefined
    };
    if (output.Item !== undefined && output.Item !== null) {
        contents.Item = deserializeAws_restJson1_1ListOfTemplateResponse(output.Item, context);
    }
    if (output.NextToken !== undefined && output.NextToken !== null) {
        contents.NextToken = output.NextToken;
    }
    return contents;
};
const deserializeAws_restJson1_1TreatmentResource = (output, context) => {
    let contents = {
        __type: "TreatmentResource",
        Id: undefined,
        MessageConfiguration: undefined,
        Schedule: undefined,
        SizePercent: undefined,
        State: undefined,
        TemplateConfiguration: undefined,
        TreatmentDescription: undefined,
        TreatmentName: undefined
    };
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.MessageConfiguration !== undefined &&
        output.MessageConfiguration !== null) {
        contents.MessageConfiguration = deserializeAws_restJson1_1MessageConfiguration(output.MessageConfiguration, context);
    }
    if (output.Schedule !== undefined && output.Schedule !== null) {
        contents.Schedule = deserializeAws_restJson1_1Schedule(output.Schedule, context);
    }
    if (output.SizePercent !== undefined && output.SizePercent !== null) {
        contents.SizePercent = output.SizePercent;
    }
    if (output.State !== undefined && output.State !== null) {
        contents.State = deserializeAws_restJson1_1CampaignState(output.State, context);
    }
    if (output.TemplateConfiguration !== undefined &&
        output.TemplateConfiguration !== null) {
        contents.TemplateConfiguration = deserializeAws_restJson1_1TemplateConfiguration(output.TemplateConfiguration, context);
    }
    if (output.TreatmentDescription !== undefined &&
        output.TreatmentDescription !== null) {
        contents.TreatmentDescription = output.TreatmentDescription;
    }
    if (output.TreatmentName !== undefined && output.TreatmentName !== null) {
        contents.TreatmentName = output.TreatmentName;
    }
    return contents;
};
const deserializeAws_restJson1_1VoiceChannelResponse = (output, context) => {
    let contents = {
        __type: "VoiceChannelResponse",
        ApplicationId: undefined,
        CreationDate: undefined,
        Enabled: undefined,
        HasCredential: undefined,
        Id: undefined,
        IsArchived: undefined,
        LastModifiedBy: undefined,
        LastModifiedDate: undefined,
        Platform: undefined,
        Version: undefined
    };
    if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
        contents.ApplicationId = output.ApplicationId;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.Enabled !== undefined && output.Enabled !== null) {
        contents.Enabled = output.Enabled;
    }
    if (output.HasCredential !== undefined && output.HasCredential !== null) {
        contents.HasCredential = output.HasCredential;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.IsArchived !== undefined && output.IsArchived !== null) {
        contents.IsArchived = output.IsArchived;
    }
    if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
        contents.LastModifiedBy = output.LastModifiedBy;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.Platform !== undefined && output.Platform !== null) {
        contents.Platform = output.Platform;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    return contents;
};
const deserializeAws_restJson1_1VoiceTemplateResponse = (output, context) => {
    let contents = {
        __type: "VoiceTemplateResponse",
        Arn: undefined,
        Body: undefined,
        CreationDate: undefined,
        DefaultSubstitutions: undefined,
        LanguageCode: undefined,
        LastModifiedDate: undefined,
        TemplateDescription: undefined,
        TemplateName: undefined,
        TemplateType: undefined,
        Version: undefined,
        VoiceId: undefined,
        tags: undefined
    };
    if (output.Arn !== undefined && output.Arn !== null) {
        contents.Arn = output.Arn;
    }
    if (output.Body !== undefined && output.Body !== null) {
        contents.Body = output.Body;
    }
    if (output.CreationDate !== undefined && output.CreationDate !== null) {
        contents.CreationDate = output.CreationDate;
    }
    if (output.DefaultSubstitutions !== undefined &&
        output.DefaultSubstitutions !== null) {
        contents.DefaultSubstitutions = output.DefaultSubstitutions;
    }
    if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
        contents.LanguageCode = output.LanguageCode;
    }
    if (output.LastModifiedDate !== undefined &&
        output.LastModifiedDate !== null) {
        contents.LastModifiedDate = output.LastModifiedDate;
    }
    if (output.TemplateDescription !== undefined &&
        output.TemplateDescription !== null) {
        contents.TemplateDescription = output.TemplateDescription;
    }
    if (output.TemplateName !== undefined && output.TemplateName !== null) {
        contents.TemplateName = output.TemplateName;
    }
    if (output.TemplateType !== undefined && output.TemplateType !== null) {
        contents.TemplateType = output.TemplateType;
    }
    if (output.Version !== undefined && output.Version !== null) {
        contents.Version = output.Version;
    }
    if (output.VoiceId !== undefined && output.VoiceId !== null) {
        contents.VoiceId = output.VoiceId;
    }
    if (output.tags !== undefined && output.tags !== null) {
        contents.tags = deserializeAws_restJson1_1MapOf__string(output.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1_1WaitActivity = (output, context) => {
    let contents = {
        __type: "WaitActivity",
        NextActivity: undefined,
        WaitTime: undefined
    };
    if (output.NextActivity !== undefined && output.NextActivity !== null) {
        contents.NextActivity = output.NextActivity;
    }
    if (output.WaitTime !== undefined && output.WaitTime !== null) {
        contents.WaitTime = deserializeAws_restJson1_1WaitTime(output.WaitTime, context);
    }
    return contents;
};
const deserializeAws_restJson1_1WaitTime = (output, context) => {
    let contents = {
        __type: "WaitTime",
        WaitFor: undefined,
        WaitUntil: undefined
    };
    if (output.WaitFor !== undefined && output.WaitFor !== null) {
        contents.WaitFor = output.WaitFor;
    }
    if (output.WaitUntil !== undefined && output.WaitUntil !== null) {
        contents.WaitUntil = output.WaitUntil;
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    httpHeaders: output.headers,
    requestId: output.headers["x-amzn-requestid"]
});
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody, context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return (context.streamCollector(streamBody) || Promise.resolve(new Uint8Array()));
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => {
    return collectBody(streamBody, context).then(body => context.utf8Encoder(body));
};
const parseBody = (streamBody, context) => {
    return collectBodyString(streamBody, context).then(encoded => {
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
};
/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
    return "";
};
//# sourceMappingURL=Aws_restJson1_1.js.map